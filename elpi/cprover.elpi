
shorten prover.{ and_l, and_r, or_l, or1_r, or2_r, orc_r, ex-falso, initial,
                 imp_l, imp_r, forall_l, exists_r, proof }.

namespace prover {


%%% ---------------------------------------------------------------------------
%%% Simple intuitionistic prover.
%%% ---------------------------------------------------------------------------

pred memb_and_rest o:A, o:list A, o:list A.

memb_and_rest A [A|L] L.
memb_and_rest A [B|L] [B|K] :- memb_and_rest A L K.

%% ----------------------------------------------------------------------------
%% FOL formulas.
%% ----------------------------------------------------------------------------

kind formula type -> type -> type.

type and, or, imp       formula I A -> formula I A -> formula I A.
%type neg               formula I A -> formula I A.
type forall, exists     I -> (I -> formula I A) -> formula I A.
type bottom             formula I A.
type atom               A -> formula I A.

infixl or  4.
infixl and 5.
infixr imp 6.
infix -->   3.

kind  seq   type -> type.
type  -->   list (formula I A) -> list (formula I A) -> seq (formula I A).

type  forall_r  (I -> A) -> (I -> proof I A) -> proof I A.
type  exists_l  (I -> A) -> (I -> proof I A) -> proof I A.

% TODO: Check this.
pred memb i:formula I A, i:list (formula I A).
memb A L :- std.mem L A.

pred search i:bool, o:proof I (formula I A), i:seq (formula I A).

%%% Step 1.

search S (and_l A B P) (Gamma --> Delta) :-
    memb_and_rest (A and B) Gamma Gamma1,
    search S P ([A,B|Gamma1] --> Delta).

search _S (initial A) (Gamma --> Delta) :-
    memb A Gamma, memb A Delta.

search S (and_r P1 P2) (Gamma --> Delta) :-
    memb_and_rest (A and B) Delta Delta1,
    search S P1 (Gamma --> [A|Delta1]),
    search S P2 (Gamma --> [B|Delta1]).

search S (imp_l A B P1 P2) (Gamma --> Delta) :-
    memb_and_rest (A imp B) Gamma Gamma1,
    search S P1 (Gamma1 --> [A|Delta]),
    search S P2 ([B|Gamma1] --> Delta).

search S (imp_r P) (Gamma --> Delta) :-
    memb_and_rest (A imp B) Delta Delta1,
    search S P ([A|Gamma] --> [B|Delta1]).

search S (forall_r A P) (Gamma --> Delta) :-
    memb_and_rest (forall _ A) Delta Delta1,
    std.spy(pi T\ search S (P T) (Gamma --> [A T|Delta1])).

search S (exists_l A P) (Gamma --> Delta) :-
    memb_and_rest (exists _ A) Gamma Gamma1,
    pi T\ search S (P T) ([A T|Gamma1] --> Delta).

search _S ex-falso (Gamma --> _Delta) :-
    std.mem! Gamma bottom.

search S (or_l A B P Q) (Gamma --> Delta) :-
    memb_and_rest (A or B) Gamma Gamma1,
    search S P ([A|Gamma1] --> Delta),
    search S Q ([B|Gamma1] --> Delta).
/*
search S (orc_r P) (Gamma --> Delta) :-
    memb_and_rest (A or B) Delta Delta1,
    search S P (Gamma --> [A,B|Delta1]).
*/
search S (or1_r P) (Gamma --> Delta) :-
    memb_and_rest (A or B) Delta Delta1,
    search S P (Gamma --> [A|Delta1]).

search S (or2_r P) (Gamma --> Delta) :-
    memb_and_rest (A or B) Delta Delta1,
    search S P (Gamma --> [B|Delta1]).


search ff P Seq :-
    (nsearch 1 P Seq).

%%% Step 2

search tt (forall_l X (forall V A) P) (Gamma --> Delta) :-
    memb_and_rest (forall V A) Gamma Gamma1,
    search tt P ([A X|Gamma1] --> Delta).

search tt (exists_r T P) (Gamma --> Delta) :-
    memb_and_rest (exists _ A) Delta Delta1,
    search tt P (Gamma --> [A T|Delta1]).

%% ----------------------------------------------------------------------------
%% Iterative deepening.
%% ----------------------------------------------------------------------------

pred nsearch i:int, o:proof I (formula I A), i:seq (formula I A).
nsearch N P Seq :- N > 5, !, fail. % halt "too deep".
nsearch N P Seq :- std.spy(amplify N Seq ASeq), search tt P ASeq, !.
nsearch N P Seq :- M is N + 1, print "Search at depth " M, nsearch M P Seq.

%% ----------------------------------------------------------------------------
%% Amplify.
%% ----------------------------------------------------------------------------

pred amplify i:int, i:seq (formula I A), o:seq (formula I A).
amplify 1 Seq Seq.
amplify N (Gamma1 --> Delta1) (Gamma2 --> Delta2) :-
    N > 1,
    amplify_forall N Gamma1 Gamma2,
    amplify_exists N Delta1 Delta2.

pred add_copies i:int, i:A, i:list A, o:list A.
add_copies 1 A L [A|L].
add_copies N A L [A|K] :-
    N > 1, M is N - 1,
    add_copies M A L K.

pred amplify_forall i:int, i:list (formula I A), o:list (formula I A).
amplify_forall _N [] [].
amplify_forall N [forall I A|Gamma] Gamma2 :-
    amplify_forall N Gamma Gamma1,
    add_copies N (forall I A) Gamma1 Gamma2.
amplify_forall N [A|Gamma] [A|Gamma1] :-
    amplify_forall N Gamma Gamma1.

pred amplify_exists i:int, i:list (formula I A), o:list (formula I A).
amplify_exists _N [] [].
amplify_exists N [exists I A|Delta] Delta2 :-
    amplify_exists N Delta Delta1,
    add_copies N (exists I A) Delta1 Delta2.
amplify_exists N [A|Delta] [A|Delta1] :-
    amplify_exists N Delta Delta1.

pred start o:proof I (formula I A), i:list (formula I A), i:list (formula I A).
start P H C :- search ff P (H --> C).

/*

%% ----------------------------------------------------------------------------
%% Nominal variant of forall_r and exists_l proof constructors.
%% ----------------------------------------------------------------------------

type  nforall_r  I -> formula I A -> proof I A -> proof I A.
type  nexists_l  I -> formula I A -> proof I A -> proof I A.

%% ----------------------------------------------------------------------------
%% Translation to nomial proofs.
%% ----------------------------------------------------------------------------

pred nproof i:proof I A, o:proof I A.

nproof ex-falso ex-falso.
nproof (initial A) (initial A).
nproof (and_l A B P) (and_l A B Q)       :- nproof P Q.
nproof (and_r P1 P2) (and_r Q1 Q2)       :- nproof P1 Q1, nproof P2 Q2.
nproof (or_l A B P1 P2) (or_l A B Q1 Q2) :- nproof P1 Q1, nproof P2 Q2.
nproof (orc_r P) (orc_r Q)               :- nproof P Q.
nproof (imp_l P1 P2) (imp_l Q1 Q2)       :- nproof P1 Q1, nproof P2 Q2.
nproof (imp_r A P) (imp_r A Q)           :- nproof P Q.
nproof (forall_l P) (forall_l Q)         :- nproof P Q.
nproof (exists_r X P) (exists_r X Q)     :- nproof P Q.

type tvar int -> i.

nproof (forall_r A P) (nforall_r (tvar N) (A X) (P X)) :-
    new_int N, X = tvar N.

nproof (exists_l A P) (nexists_l (tvar N) (A X) (P X)) :-
    new_int N, X = tvar N.
*/

%% ----------------------------------------------------------------------------
%% Tests.
%% ----------------------------------------------------------------------------

kind form type.
kind i    type.

type c  i.
type f  i -> i -> i.
type q  form.
type p  i -> form.
type x form.
type d i -> form.

pred test.
test :-
    std.spy(start P  [atom x] [atom x]), !,
    std.spy(start P2 [bottom] [bottom]), !,
    std.spy(start P4 [] [(atom x or ((atom x) imp bottom))]), !,
    std.spy(start P3 []  [exists _ x\ (atom (d x)) imp (forall _ y\ atom (d y))]).
    %std.spy(nproof P3 P3N).

}

% TODO: elpi should "patch" notations inside namespaces automatically
infixl prover.or  4.
infixl prover.and 5.
infixr prover.imp 6.