%%% ---------------------------------------------------------------------------
%%% Simple intuitionistic prover.
%%% ---------------------------------------------------------------------------

pred memb_and_rest o:A, o:list A, o:list A.

memb_and_rest A [A|L] L.
memb_and_rest A [B|L] [B|K] :- memb_and_rest A L K.

pred test1 o:list A.
test1 L :- std.spy(memb_and_rest 2 [1,2,3,4] L).
test1 L :- std.spy(memb_and_rest 0 L [1,2,3]).

%% ----------------------------------------------------------------------------
%% FOL formulas.
%% ----------------------------------------------------------------------------

kind form type.
kind i    type.

type and, or, imp       form -> form -> form.
%type neg                form -> form.
type forall, exists     (i -> form) -> form.
type bottom              form.

infixl or  4.
infixl and 5.
infixr imp 6.

type c  i.
type f  i -> i -> i.
type q  form.
type p  i -> form.


kind  seq   type.
type  -->   list form -> list form -> seq.
infix -->   3.

kind  proof     type.

type  and_l     proof -> proof.
type  and_r     proof -> proof -> proof.

type  or_l      form -> form -> proof -> proof -> proof.
type  or1_r     form -> proof -> proof.
type  or2_r     form -> proof -> proof.
type  orc_r     proof -> proof.

type  ex-falso  proof.

type  initial   form -> proof.

type  imp_l     proof -> proof -> proof.
type  imp_r     form -> proof -> proof.

type  forall_l  proof -> proof.
type  exists_r  i -> proof -> proof.

type  forall_r  (i -> form) -> (i -> proof) -> proof.
type  exists_l  (i -> form) -> (i -> proof) -> proof.

% TODO: Check this.
pred memb i:form, i:list form.
memb A L :- std.mem L A.

pred proof i:bool, o:proof, i:seq.

%%% Step 1.

proof S (and_l P) (Gamma --> Delta) :-
    memb_and_rest (A and B) Gamma Gamma1,
    proof S P ([A,B|Gamma1] --> Delta).

proof _S (initial A) (Gamma --> Delta) :-
    memb A Gamma, memb A Delta.

proof S (and_r P1 P2) (Gamma --> Delta) :-
    memb_and_rest (A and B) Delta Delta1,
    proof S P1 (Gamma --> [A|Delta1]),
    proof S P2 (Gamma --> [B|Delta1]).

proof S (imp_l P1 P2) (Gamma --> Delta) :-
    memb_and_rest (A imp B) Gamma Gamma1,
    proof S P1 (Gamma1 --> [A|Delta]),
    proof S P2 ([B|Gamma1] --> Delta).

proof S (imp_r A P) (Gamma --> Delta) :-
    memb_and_rest (A imp B) Delta Delta1,
    proof S P ([A|Gamma] --> [B|Delta1]).

proof S (forall_r A P) (Gamma --> Delta) :-
    memb_and_rest (forall A) Delta Delta1,
    std.spy(pi T\ proof S (P T) (Gamma --> [A T|Delta1])).

proof S (exists_l A P) (Gamma --> Delta) :-
    memb_and_rest (exists A) Gamma Gamma1,
    pi T\ proof S (P T) ([A T|Gamma1] --> Delta).

proof _S ex-falso (Gamma --> _Delta) :-
    std.mem! Gamma bottom.

proof S (or_l A B P Q) (Gamma --> Delta) :-
    memb_and_rest (A or B) Gamma Gamma1,
    proof S P ([A|Gamma1] --> Delta),
    proof S Q ([B|Gamma1] --> Delta).

proof S (orc_r P) (Gamma --> Delta) :-
    memb_and_rest (A or B) Delta Delta1,
    proof S P (Gamma --> [A,B|Delta1]).

proof ff P Seq :-
    nprove 1 P Seq.

%%% Step 2

proof tt (forall_l P) (Gamma --> Delta) :-
    memb_and_rest (forall A) Gamma Gamma1,
    proof tt P ([A T_|Gamma1] --> Delta).

proof tt (exists_r T P) (Gamma --> Delta) :-
    memb_and_rest (exists A) Delta Delta1,
    proof tt P (Gamma --> [A T|Delta1]).

%% ----------------------------------------------------------------------------
%% Iterative deepening.
%% ----------------------------------------------------------------------------

pred nprove i:int, o:proof, i:seq.
nprove N P Seq :- N > 5, !, halt "too deep".
nprove N P Seq :- amplify N Seq ASeq, proof tt P ASeq, !.
nprove N P Seq :- M is N + 1, print "Search at depth " M, nprove M P Seq.

%% ----------------------------------------------------------------------------
%% Amplify.
%% ----------------------------------------------------------------------------

pred amplify i:int, i:seq, o:seq.
amplify 1 Seq Seq.
amplify N (Gamma1 --> Delta1) (Gamma2 --> Delta2) :-
    N > 1,
    amplify_forall N Gamma1 Gamma2,
    amplify_exists N Delta1 Delta2.

pred add_copies i:int, i:A, i:list A, o:list A.
add_copies 1 A L [A|L].
add_copies N A L [A|K] :-
    N > 1, M is N - 1,
    add_copies M A L K.

pred amplify_forall i:int, i:list form, o:list form.
amplify_forall _N [] [].
amplify_forall N [forall A|Gamma] Gamma2 :-
    amplify_forall N Gamma Gamma1,
    add_copies N (forall A) Gamma1 Gamma2.
amplify_forall N [A|Gamma] [A|Gamma1] :-
    amplify_forall N Gamma Gamma1.

pred amplify_exists i:int, i:list form, o:list form.
amplify_exists _N [] [].
amplify_exists N [exists A|Delta] Delta2 :-
    amplify_exists N Delta Delta1,
    add_copies N (exists A) Delta1 Delta2.
amplify_exists N [A|Delta] [A|Delta1] :-
    amplify_exists N Delta Delta1.

pred start o:proof, i:seq.
start P Seq :- proof ff P Seq.

%% ----------------------------------------------------------------------------
%% Tests.
%% ----------------------------------------------------------------------------

type x form.
type d i -> form.

main :-
    std.spy(start P ([x] --> [x])), !,
    std.spy(start P2 ([bottom] --> [bottom])), !,
    std.spy(start P4 ([] --> [(x or (x imp bottom))])), !,
    std.spy(start P3 ([] --> [exists x\ (d x) imp (forall y\ d y)])).
