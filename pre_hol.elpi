%%% ===========================================================================
%%% lProlog code needed for HOL-Elpi that do not depend on Hol or ML.
%%% ===========================================================================

%% ----------------------------------------------------------------------------
%% The type of pretypes.
%% ----------------------------------------------------------------------------

kind pretype type.

type uty      string -> pretype.                     % User type variable
type ptycon   string -> list pretype -> pretype.     % Type constructor
type sty      int -> pretype.                        % System type variable

%% ----------------------------------------------------------------------------
%% The of closed pretypes.
%% The first argument of ptyfree is for storing the type variable.
%% ----------------------------------------------------------------------------

kind cpretype type.

type ptybody  pretype -> cpretype.                   % Body
type ptyfree  pretype ->                             % Type variable binder
                (pretype -> cpretype) -> cpretype.

%% ----------------------------------------------------------------------------
%% Copy clauses for the pretype datatype.
%% ----------------------------------------------------------------------------

pred ptycopy i:pretype, o:pretype.

ptycopy (uty _S as X) X.
ptycopy (sty _N as X) X.
ptycopy (ptycon S Ts) (ptycon S Rs) :- std.map Ts ptycopy Rs.
% since we may put refreshed schemas inside terms and since we copy
% types attached to constp/typingp and since this predicate is not
% generative we need to handle the case in which the input is flexible
% explicitly (`uvar` is a keyword)
ptycopy (uvar as X) X.

%% ----------------------------------------------------------------------------
%% Collecting the type variables occurring in a pretype.
%% Needed as a preliminary step for computing the cpretype of a pretype.
%% ----------------------------------------------------------------------------

pred ptyvars i:pretype, i:list pretype, o:list pretype.

ptyvars (uty _S as X) Vs Vs :- std.mem Vs X, !.
ptyvars (uty _S as X) Vs [X|Vs].
ptyvars (sty _N as X) Vs Vs :- std.mem Vs X, !.
ptyvars (sty _N as X) Vs [X|Vs].
ptyvars (ptycon _S Ts) Vs Ws :- ptyvars_list Ts Vs Ws.

pred ptyvars_list i:list pretype, i:list pretype, o:list pretype.

ptyvars_list [] Vs Vs.
ptyvars_list [T|Ts] Vs Ws :- ptyvars T Vs Us, ptyvars_list Ts Us Ws.

%% ----------------------------------------------------------------------------
%% Computing the closed pretype (cpretype) associated to a pretype.
%% ----------------------------------------------------------------------------

% Closure in a given context.
pred ptyclose i:list pretype, i:pretype, o:cpretype.

ptyclose [] T (ptybody P) :- ptycopy T P.
ptyclose [V|Vs] T (ptyfree V R) :-
  (pi v\ (ptycopy V v :- !) => ptyclose Vs T (R v)).

% The main predicate: Closure of a pretype.
pred close-pretype i:pretype, o:cpretype.

close-pretype P C :- ptyvars P [] Vs, ptyclose Vs P C.

%% ----------------------------------------------------------------------------
%% The type of preterms.
%% Notice the two abstractions (absp and lamp).
%% The first argument of lamp is for storing the variable.
%% ----------------------------------------------------------------------------

kind preterm type.

type varp    string -> pretype -> preterm.           % Variable
type constp  string -> pretype -> preterm.           % Constant
type combp   preterm -> preterm -> preterm.          % Combination
type typing  preterm -> pretype -> preterm.          % Typing
type absp    preterm -> preterm -> preterm.          % Abstraction
type lamp    preterm ->                              % HO Abstraction
               (preterm -> preterm) -> preterm.

%% ----------------------------------------------------------------------------
%% Copy clauses for the preterm datatype.
%% ----------------------------------------------------------------------------

pred ptmcopy i:preterm, o:preterm.

ptmcopy (varp _ _ as X) X.
ptmcopy (constp _ _ as X) X.
ptmcopy (combp X1 Y1) (combp X2 Y2)   :- ptmcopy X1 X2, ptmcopy Y1 Y2.
ptmcopy (typing X1 T1) (typing X2 T2) :- ptmcopy X1 X2, ptycopy T1 T2.
ptmcopy (absp V1 X1) (absp V2 X2)     :- ptmcopy V1 V2, ptmcopy X1 X2.
ptmcopy (lamp V B1) (lamp V B2) :-
  pi x\ ptmcopy x x => ptmcopy (B1 x) (B2 x).
ptmcopy (uvar as X) X.

%% ----------------------------------------------------------------------------
%% The of closed preterms.
%% The first argument of ptmbind is for storing the variable.
%% ----------------------------------------------------------------------------

kind cpreterm type.

type ptmbody  preterm -> cpreterm.                    % Body
type ptmfree  preterm ->                              % Variable binder
                (preterm -> cpreterm) -> cpreterm.

%% ----------------------------------------------------------------------------
%% Collecting the variables occurring in a preterm.
%% Needed as a preliminary step for computing the cpreterm of a preterm.
%% ----------------------------------------------------------------------------

pred ptmvars i:preterm, i:list preterm, o:list preterm.

ptmvars (varp _ _ as X) Vs Vs :- std.mem Vs X, !.
ptmvars (varp _ _ as X) Vs [X|Vs].
ptmvars (constp _ _) L L.
ptmvars (combp X Y) Vs Ws :- ptmvars X Vs Us, ptmvars Y Us Ws.
ptmvars (typing X T_) Vs Ws :- ptmvars X Vs Ws.
ptmvars (lamp V_ B) Vs Ws :-
  pi x \ (pi L\ ptmvars x L L) => ptmvars (B x) Vs Ws.

%% ----------------------------------------------------------------------------
%% Turning nominal abstractions into bound HOAS abstractions and recognizes
%% global constants declared in `env`
%% That is (absp _ _) into (lamp _ _)
%%         (varp S _) into (constp S T)
%% ----------------------------------------------------------------------------

pred ptmbind i:preterm, o:preterm.
pred env i:string, o:string, o:cpretype. % env S S1 T resolve S as S1 : T
pred numeral i:string, o:preterm.

ptmbind T1 T2 :-
  (pi V T B FRESH\
     ptmcopy (absp (varp S _ as V) T) (lamp (varp S FRESH) B) :- !,
        pi v \ (ptmcopy V v :- !) => ptmcopy T (B v))
  =>
  (pi V T B S VT\
     ptmcopy (absp (typing (varp S _ as V) VT) T) (lamp (varp S VT) B) :- !,
        pi v \ (ptmcopy V v :- !) => ptmcopy T (B v))
  =>
  (pi S TY\ 
     ptmcopy (varp S TY) (constp S TY) :- (env S _ _; overload S _ _), !)
  =>
  (pi S N\ 
     ptmcopy (varp S _) N :- numeral S N, !)
  =>
  ptmcopy T1 T2.

%% ----------------------------------------------------------------------------
%% Turning bound HOAS abstractions into nominal abstractions.
%% (That is (absp _ _) into (lamp _ _).
%% ----------------------------------------------------------------------------

pred ptmunbind i:preterm, o:preterm.

ptmunbind T1 T2 :-
  (pi V T B \
     (ptmcopy (lamp V T) (absp V X) :- !, ptmcopy (T V) X))
  => ptmcopy T1 T2.

%% ----------------------------------------------------------------------------
%% Computing the closed preterm (type cpreterm) associated to a preterm.
%% ----------------------------------------------------------------------------

% Closure in a given context.
pred ptmclose i:list preterm, i:preterm, o:cpreterm.

ptmclose [] P (ptmbody Q) :- ptmcopy P Q.
ptmclose [V|Vs] P (ptmfree V B) :-
  pi v \ (ptmcopy V v :- !) => ptmclose Vs P (B v).

% The main predicate: Closure of a pretype.
pred close-term i:preterm, o:cpreterm.

close-term P T :- ptmbind P Q, ptmvars Q [] Vs, ptmclose Vs Q T, !.

%% ----------------------------------------------------------------------------
%% Computing the open preterm associated to a cpreterm.
%% ----------------------------------------------------------------------------

pred open-term i:cpreterm, o:preterm.

open-term (ptmbody X) R :- ptmunbind X R.
open-term (ptmfree V B) X :- open-term (B V) X.

%% ----------------------------------------------------------------------------
%% Typing of a preterm.
%% ----------------------------------------------------------------------------

pred refresh-cpretype i:cpretype, o:pretype.

refresh-cpretype (ptybody T) T.
refresh-cpretype (ptyfree _V F) T :- refresh-cpretype (F FRESH_) T.

 
pred overload i:string, o:string, o:cpretype. % env S S1 T resolve S as S1 : T
pred of i:preterm, o:pretype, o:preterm.

of (absp _ _) _ _ :- halt "absp".

of (typing T TY) TY R :- of-coerce T TY R.

of (constp S _) TY (constp S1 TY) :- overload S S1 CTY, refresh-cpretype CTY TY.
of (constp S _) TY (constp S TY) :- env S S CTY, refresh-cpretype CTY TY.

of (lamp (varp S Src) F) (ptycon "fun" [Src,Tgt]) (lamp (varp S Src) F1) :-
  pi x\
     (pi T\ of x T x :- !, T = Src) =>
     of (F x) Tgt (F1 x).

of (combp A B) Tgt (combp A1 B1) :-
  of A (ptycon "fun" [Src,Tgt]) A1,
  of-coerce B Src B1.

pred of-coerce i:preterm, o:pretype, o:preterm.


of-coerce A T R :-
  report-all-failures-if-no-success (
  of A T1 R1,
  (
   if (trans-coercion T1 T R1 R) true
  
    ( Msg is "The term\n\t" ^ {hol.term->string R1} ^
             "\nhas type\n\t" ^ {hol.ty->string T1} ^
             "\nthat is not\n\t" ^ {hol.ty->string T},
       error [ Msg ]
    )
  )
  ).

stash-new E S :- open_safe E L, ( std.mem L S ; stash_in_safe E S ), !.

report-all-failures-if-no-success P :-
  new_safe E,
  (((pi ML\ error ML :- !, std.forall ML (stash-new E), fail) => P)
   ;
   (error {open_safe E})).

error L :- std.forall L (x\ print "Error:" x), fail.



/*
of-coerce A T R :- of A T R.

of PTM TY TM :- /*not (var TY),*/ not (of-loop PTM),
  of-loop PTM => of PTM TY1 TM1,
  trans-coercion TY1 TY TM1 TM.
*/

trans-coercion X X1 T T :- eqq X X1, !.
trans-coercion X X T T.
trans-coercion A B T R1 :-
  coercions Coercions,
  mem Coercions (coercion S TS),
  refresh-cpretype TS (ptycon "fun" [A, A1]),
  trans-coercion A1 B (combp (constp S (ptycon "fun" [A, A1])) T) R1.

pred eqq i:pretype, i:pretype.
eqq (ptycon S L1) (ptycon S L2) :- eqq-list L1 L2.
eqq (uty N) (uty N).
eqq (sty N) (sty N).
eqq (uvar A) (uvar B) :- same_var A B.

pred eqq-list i:list pretype, i:list pretype.
eqq-list [] [].
eqq-list [X|XS] [Y|YS] :- eqq X Y, eqq-list XS YS.


% HOL-light coercion
kind coercion type.
type coercion string -> cpretype -> coercion.

pred coercions o:list coercion.

pred mem i:list A, o:A.
mem [X|_] X.
mem [_|Xs] X :- mem Xs X.

pred of-c i:cpreterm, o:pretype, o:cpreterm.

of-c (ptmbody X) T (ptmbody X1) :- of X T X1.
of-c (ptmfree (varp S _) B) T (ptmfree (varp S Ty) B1) :-
  pi x\
     (pi T\ of x T x :- !, Ty = T) =>
     of-c (B x) T (B1 x).

pred elab i:preterm, o:preterm.

elab T R :- 
  close-term T TC,
  print T "-c->" TC,
  report-all-failures-if-no-success (of-c TC Type ETC),
  print TC "-e->" ETC ":" Type, 
  open-term ETC R
.

%% ----------------------------------------------------------------------------
%% Tactics.
%% ----------------------------------------------------------------------------

pred prove i:preterm, o:@thm.

%% ----------------------------------------------------------------------------
%% Some tests.
%% ----------------------------------------------------------------------------

pred test1 i:(A->prop).
pred test1ok i:(A->prop).

test1ok P :-
  print "Test >>>" P, P Result, !, print "  OK <<<" Result;
  print "  FAILURE: " P.

test1 P :-
  print "Test >>>" P, P Result, !, print "  OK <<<" Result;
  print "  FAILURE: " P.

pred tests i:list any.

tests [].
tests [T|Ts] :- test1 T, tests Ts.

macro @dummy :- ptycon "" [].
macro @fun L :- ptycon "fun" L.
macro @con X :- ptycon X [].

main :-
  print "Tests start ...",
  test1ok (ptyvars (uty "x") []),
  test1   (ptyvars (sty 1) []),
  test1 (ptyvars (ptycon "y" [uty "x", sty 3]) []),
  test1 (ptyclose [uty "x"] (uty "x")),
  test1 (ptyclose [sty 1] (uty "x")),
  test1 (close-pretype (ptycon "fun" [uty "x", sty 1])),
  test1 (ptmbind (absp (varp "x" (uty "t")) (varp "x" (uty "t")))),
  test1 (ptmbind (absp (varp "x" (sty 0)) (varp "x" (uty "t")))),
  test1 (ptmvars (combp (varp "x" (uty "t")) (varp "y" (sty 1))) []),
  test1 (close-term (varp "x" (uty "t"))),
  test1 (close-term (absp (varp "x" (uty "t"))
                          (combp (varp "x" (uty "t")) (varp "x" (uty "s"))))),
  (env "0" "0" (ptybody (ptycon "num" []))) =>
    test1 (close-term (absp (varp "x" (uty "t"))
                             (combp (varp "y" (uty "t"))
                              (combp (varp "x" (uty "t")) (varp "0" @dummy))))),
  (env "0" "0" (ptybody (ptycon "num" []))) =>
    test1 (elab (absp (varp "x" (uty "t"))
                             (combp (varp "y" (uty "t"))
                              (combp (varp "x" (uty "t")) (varp "0" @dummy))))),
  (env "0" "0" (ptybody (ptycon "num" []))) =>
  (env "real_of_num" "real_of_num" (ptybody (@fun [@con "num", @con "real"]))) =>
  (coercions [coercion "real_of_num" (ptybody (@fun [@con "num", @con "real"]))]) =>
    test1 (elab (absp (typing (varp "x" (uty "t")) (@fun [@con "real", @con "bool"]))
                             (combp (varp "y" (uty "t"))
                              (combp (varp "x" (uty "t")) (varp "0" @dummy))))),
 (env "0" "0" (ptybody (ptycon "num" []))) =>
 (env "real_of_num" "real_of_num" (ptybody (@fun [@con "num", @con "real"]))) =>
 (env "complex_of_real" "complex_of_real" (ptybody (@fun [@con "real", @con "complex"]))) =>

  (coercions [coercion "real_of_num"     (ptybody (@fun [@con "num",  @con "real"])),
              coercion "complex_of_real" (ptybody (@fun [@con "real", @con "complex"]))
             ]) =>
    test1 (elab (absp (typing (varp "x" (uty "t")) (@fun [@con "complex", @con "bool"]))
                              (combp (varp "x" (uty "t")) (varp "0" @dummy)))),


  print "... tests finished.".
