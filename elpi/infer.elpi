%%% ===========================================================================
%%% Type inference and term reconstruction.
%%%
%%% An experiment using continuation-passing style.
%%% ===========================================================================

%% ----------------------------------------------------------------------------
%% Variable name convention:
%% A, B, C pretypes;
%%       D dummy pretype;
%%       V preterm variable;
%% X, Y, F arbitrary preterm;
%%       S string (name of a variable or a constant).
%% ----------------------------------------------------------------------------

%% ----------------------------------------------------------------------------
%% Handy macros for building pretypes and preterms.
%% ----------------------------------------------------------------------------

% Types.
macro @tvar S :- varp S (ptycon "" []).
macro @tcon A :- ptycon A [].
macro @tbool  :- @tcon  "bool".
macro @tnum   :- @tcon  "num".
macro @treal  :- @tcon  "real".
macro @tind   :- @tcon  "ind".
macro @tdty   :- ptycon  "" [].
macro @tfun A B :- ptycon  "fun" [A, B].
macro @funp L :- ptycon  "fun" L.
macro @tfun2 A B C :- @tfun A (@tfun B C).

% Terms.
macro @tbinop Op X Y :- combp (combp Op X) Y.

%% ----------------------------------------------------------------------------
%% Entrypoint.
%% ----------------------------------------------------------------------------

pred elaborate i:preterm, o:preterm.
elaborate X Y :-
  freevars X Vs,
  std.map Vs build-fvar-clause P,
  P => ((coercions [] :- !) => infer X Y _).

pred build-fvar-clause i:string, o:prop.
build-fvar-clause S
  (pi X A \ infer (varp S _) X A :- !, X = varp S A1, A = A1).

%% ----------------------------------------------------------------------------
%% Main inference predicate.
%%
%%   infer X Y A.
%%
%% Where:
%%   X = input (parsed) term;
%%   Y = output (inferred) term;
%%   A = inferred type (type of Y).
%% ----------------------------------------------------------------------------

pred infer i:preterm, o:preterm, o:pretype.

%%% Variables.

:name "infer:numeral"
infer (varp S _) N @tnum :- numeral S N, !.
:name "infer:overload"
infer (varp S _) X A :- hol.interface S L, infer.overload S L X A.

pred infer.overload i:string, i:list(pair string pretype), o:preterm, o:pretype.
infer.overload S [] (constp S A) A :- hol.env S C, !, close-pretype C CT, refresh-cpretype CT A.
infer.overload S [] (varp S A) A :- skeleton S A, !.
infer.overload _ [pr S1 K] X A :- !,
  close-pretype K C,
  refresh-cpretype C A,
  infer.env S1 X A.
infer.overload _ ((_ :: _ :: _) as L) X A :-
  std.mem L (pr S1 K),
  close-pretype K C,
  refresh-cpretype C A,
  infer.env S1 X A.

pred infer.env i:string, o:preterm, o:pretype.
infer.env S (constp S A) A :- hol.env S C, !, close-pretype C CT, refresh-cpretype CT A.
infer.env S (varp   S A) A.

%%% Combinations.

:name "infer:app"
infer (combp F X) (combp F1 X1) B :-
  infer F F1 (@tfun A B),
  infer X X1 A.
  %% Version with coercions.
  %% TODO: Diverges in some cases.  Why?
  % infer F F1 (@tfun A B),
  % (infer X X1 A; infer-coerce X X1 A).

%%% Abstractions.
%%% NB: the HOL function `term_of_preterm` takes care of
%%% returning a generalized abstraction when needed.

%% Anchor point to enrich
pred infer.knowledge i:preterm, i:pretype, o:list prop.
:name "infer:lam:knowledge"
infer.knowledge _ _ [].

:name "infer:lam"
infer (absp X Y) (absp X1 Y1) (@tfun A B) :-
  freevars X Us,
  std.map Us build-fvar-clause P,
  P => (infer X X1 A, infer.knowledge X1 A CL, CL => infer Y Y1 B).

%%% Clause that produces the concrete form of the generalized abstraction.
%%% This predicate and the next two are not used now.
pred infer-gabs-clause o:prop.
infer-gabs-clause
  ( pi X Y Z A B X1 Y1 Us Vs \
      infer (absp X Y) Z (@tfun A B) :-
        freevars X Us,
        std.map Us build-fvar-clause P,
        P => std.map Us var-of-string Vs,
        P => (infer X X1 A, infer Y Y1 B, pmk_gabs A B Vs X1 Y1 Z)
  ).

pred pmk_gabs i:pretype, i:pretype, i:list preterm,
              i:preterm, i:preterm, o:preterm.
pmk_gabs _ _ _ (varp _ _ as V) X (absp V X) :- !.
pmk_gabs A B Vs X Y (@gabs A B (absp F Z)) :-
  F = varp "f" (@tfun A B),
  list_pmk_forall Vs (@geq B (combp F X) Y) Z.

pred var-of-string i:string, o:preterm.
var-of-string S X :- infer (varp S (ptycon "" [])) X _.

macro @geq A X Y :- @tbinop (constp "GEQ" (@tfun2 A A @tbool)) X Y.
macro @gabs A B X :-
  combp (constp "GABS" (@tfun (@tfun (@tfun A B) @tbool) (@tfun A B))) X.

%%% Type annotations.

:name "infer:cast"
infer (typing X A) X1 A :-
  infer X X1 A.
  %% Version with coercions.
  %% TODO: Diverges in some cases.  Why?
  % (infer X X1 A; infer-coerce X X1 A).

pred infer-coerce i:preterm, o:preterm, o:pretype.
infer-coerce X Y A :-
  infer X Z A1,
  trans-coercion A1 A Z Y.

%% ----------------------------------------------------------------------------
%% Further macros.
%% ----------------------------------------------------------------------------

%% Type variables.
macro @aty :- uty  "A".
macro @bty :- uty  "B".

% Term variables.
macro @a :- varp "a" @tdty.
macro @b :- varp "b" @tdty.
macro @x :- varp "x" @tdty.
macro @y :- varp "y" @tdty.
macro @z :- varp "z" @tdty.
macro @f :- varp "f" @tdty.
macro @g :- varp "g" @tdty.
macro @h :- varp "h" @tdty.

% Simple terms.
macro @i S :- varp S @tdty.

% Binary operators.
macro @eqvar X Y :- combp (combp (@i "eq") X) Y.
macro @pr X Y :- combp (combp (@i "pr") X) Y.

macro @eq A X Y :- @tbinop (constp "eq" (@tfun2 A A @tbool)) X Y.
macro @id A X :- combp (constp "id" (@tfun A A)) X.

%% ----------------------------------------------------------------------------
%% Extend testing framework.
%% ----------------------------------------------------------------------------

shorten test.{ test, run-tests, run-test, success, failure,
               skip, ok, ko, ok-all, ok-ex, okb, kob, ok-eq, assert, section }.
shorten verbosity.{ quiet, terse, info, verbose, debug, with-verbosity }.

type ok-elaborate preterm -> preterm -> test.
type ko-elaborate preterm -> test.

run-test (ok-elaborate X Y) Ret :-
  freevars X Vs, !,
  std.map Vs build-fvar-clause P,
  P => ((coercions [] :- !) => infer X Z A; infer X Z A),
  !,
  if (Y = Z) % TODO: Implement a more clever comparison.
    (
      if (has_type Z A1)
        (
          if (A == A1)
            ( Ret = success "" )
            ( Ret = failure "Wrong type" )
        ) (
          Msg is "Malformed term (has_type fails)\n" ^
                 {term_to_string X} ^ "\n-->\n" ^ {term_to_string Z},
          Ret = failure Msg
        )
    ) (
      Ret = failure Msg,
      Msg is "Success with wrong return vaule.\nExpected: " ^
             {term_to_string Y} ^ "\nReturned: " ^ {term_to_string Z}
    ).
run-test (ok-elaborate _ Y) (failure Msg) :-
  Msg is "Call failed.  Expected: " ^ {term_to_string Y}.
run-test (ko-elaborate X) (failure Msg) :- elaborate X Y, !,
  Msg is "Should fail.\nReturned: " ^ {term_to_string Y}.
run-test (ko-elaborate _) (success "").

%% ----------------------------------------------------------------------------
%% Tests.
%% ----------------------------------------------------------------------------

pred interface.bogus i:string, o:list(pair string pretype).
interface.bogus "<=>" [ pr "=" ( @tfun (uty "A") (@tfun (uty "A") @tbool) ) ].
interface.bogus "z"
  [ pr "u" (@tfun @tnum @tind)
  , pr "v" (@tfun @tbool @tind)
  ] :- !.
interface.bogus _ [].

pred skeleton.bogus i:string, o:cpretype.
skeleton.bogus "z" (ptyfree (uty "A") A \ ptybody (@tfun A @tind)).

pred status o:list prop.
status
  [ env "a" "a" (ptybody @tnum)
  , env "b" "b" (ptybody @tbool)
  , env "f" "f" (ptybody (@tfun @tnum @tnum))
  , env "g" "g" (ptybody (@tfun2 @tnum @tbool @tnum))
  , env "id" "id" (ptyfree @aty A \ ptybody (@tfun A A))
  , env "eq" "eq" (ptyfree @aty A \ ptybody (@tfun2 A A @tbool))
  , env "=" "=" (ptyfree @aty A \ ptybody (@tfun2 A A @tbool))
  , overload "z" "u" (ptybody (@tfun @tnum @tind))
  , overload "z" "v" (ptybody (@tfun @tbool @tind))
  , ( pi S L \ hol.interface S L :- interface.bogus S L )
  , ( pi S C \ skeleton S A :- skeleton.bogus S C, refresh-cpretype C A )
  ].

pred infer_test o:test.
infer_test T :-
  status PP,
  T =
  assert PP
  ( section "infer_test"
    [ section "has_type"
      [ ok-eq (@tfun @tbool @tnum)
          (has_type
            (@gabs @tbool @tnum
              (varp "u" (@tfun (@tfun @tbool @tnum) @tbool))))
      , ok-eq @tbool
          (has_type (@geq @tbool (varp "x" @tbool) (varp "x" @tbool)))
      ]
    , section "pmk_gabs"
      [ ok-eq
          (combp
            (constp "GABS"
              (@funp [@funp [@tfun @tnum @tnum, @tbool], @tfun @tnum @tnum]))
            (absp (varp "f" (@tfun @tnum @tnum))
              (combp
                (constp "!" (@funp [@funp [@tnum, @tbool], @tbool]))
                (absp (varp "m" @tnum)
                  (combp
                    (constp "!"
                      (@funp [@funp [@tfun @tnum @tnum, @tbool], @tbool]))
                    (absp (varp "s" (@tfun @tnum @tnum))
                      (combp
                        (combp
                          (constp "GEQ" (@funp [@tnum, @funp [@tnum, @tbool]]))
                          (combp
                            (varp "f" (@tfun @tnum @tnum))
                            (combp (varp "s" (@tfun @tnum @tnum))
                              (varp "m" @tnum)))) (varp "x" @tnum))))))))
          (pmk_gabs @tnum @tnum [varp "m" @tnum, varp "s" (@tfun @tnum @tnum)]
            (combp (varp "s" (@tfun @tnum @tnum))
                   (varp "m" @tnum))
            (varp "x" @tnum))
      ]
    , section "Elaborate"
      [ ok-elaborate @a (constp "a" @tnum)
      , ok-elaborate (typing @x @bty) (varp "x" @bty)
      , ok-elaborate (combp @f @a)
          (combp (constp "f" (@tfun @tnum @tnum)) (constp "a" @tnum))
      , ok-elaborate (typing (combp @h @a) @tbool)
          (combp (varp "h" (@tfun @tnum @tbool)) (constp "a" @tnum))
      , ok-elaborate (combp @z @a)
          (combp (varp "u" (@tfun @tnum @tind)) (constp "a" @tnum))
      , ok-elaborate (combp @z @b)
          (combp (varp "v" (@tfun @tbool @tind)) (constp "b" @tbool))
      , ko-elaborate (combp @f @b)
      , ko-elaborate (combp @a @b)
      , ok-elaborate (combp @g @a)
          (combp (constp "g" (@tfun2 @tnum @tbool @tnum)) (constp "a" @tnum))
      , ko-elaborate (combp @g @b)
      , ok-elaborate (combp (@i "id") @a) (@id @tnum (constp "a" @tnum))
      , ok-elaborate (combp (@i "id") @b) (@id @tbool (constp "b" @tbool))
      , ok-elaborate (combp (@i "id") (typing @x @aty))
          (@id @aty (varp "x" @aty))
      , ok-elaborate (@eqvar @a @x)
          (@eq @tnum (constp "a" @tnum) (varp "x" @tnum))
      , ok-elaborate (typing (absp @x @x) (@tfun @aty @aty))
          (absp (varp "x" @aty) (varp "x" @aty))
      , ok-elaborate
          (combp (varp "<=>" (ptycon "" []))
            (varp "x" (ptycon "" [])))
          (combp (constp "=" (@tfun @tbool (@tfun @tbool @tbool)))
            (varp "x" @tbool))
      , ok-elaborate (@eqvar (@i "id") (absp @x @a))
          (@eq (@tfun @tnum @tnum)
               (constp "id" (@tfun @tnum @tnum))
               (absp (varp "x" @tnum) (constp "a" @tnum)))
      , ( ok-eq
            (combp
              (constp "GABS"
                (ptycon "fun"
                  [@funp [(@tfun @tnum @tnum), @tbool],
                   (@tfun @tnum @tnum)]))
              (absp
                (varp "f" (@tfun @tnum @tnum))
                (combp
                  (constp "!"
                    (ptycon "fun"
                      [@funp [@tnum, @tbool], @tbool]))
                  (absp (varp "x" @tnum)
                    (combp
                      (combp
                        (constp "GEQ"
                          (ptycon "fun"
                            [@tnum, @funp [@tnum, @tbool]]))
                        (combp
                          (varp "f" (@tfun @tnum @tnum))
                          (combp (constp "f" ((@tfun @tnum @tnum)))
                            (varp "x" @tnum)))) (varp "x" @tnum))))))
            R \ infer-gabs-clause H,
                H => elaborate (absp (combp @f @x) @x) R
        )
      ]
    ]
  ).

macro @num0 :-
  (combp (constp "NUMERAL" (ptycon "fun" [ptycon "num" [], ptycon "num" []]))
    (constp "_0" (ptycon "num" []))).

pred elaborate_tests o:test.
elaborate_tests T :-
  tiny_env TinyEnv,
  small_env SmallEnv,
  T =
  section "elaborate_tests"
  [ assert TinyEnv
    ( section "elaborate"
      [ ok-eq
          (absp (varp "x" (@funp [@tnum, @tcon "1"]))
            (combp (varp "y" (@funp [@tcon "1", @tcon "2"]))
              (combp (varp "x" (@funp [@tnum, @tcon "1"]))
                @num0)))
          (elaborate (absp (varp "x" (uty "t"))
            (combp (varp "y" (uty "t"))
              (combp (varp "x" (uty "t")) (@tvar "0")))))
      , skip
        (section "elaborate w/ coercions"
        [ ok-eq
            (absp (varp "x" (@funp [@treal, @tbool]))
              (combp (varp "y" (@funp [@tbool, @tcon "1"]))
                (combp (varp "x" (@funp [@treal, @tbool]))
                  (combp
                    (constp "real_of_num" (@funp [@tnum, @treal]))
                    @num0))))
            (elaborate
              (absp (typing (varp "x" (uty "t")) (@funp [@treal, @tbool]))
                (combp (varp "y" (uty "t"))
                  (combp (varp "x" (uty "t")) (@tvar "0")))))
        ])
      ]
    )
  , assert SmallEnv
    (skip
    ( section "elaborate2"
      [ ok-eq
          (absp (varp "x" (@funp [ptycon "complex" [], @tbool]))
            (combp (varp "x" (@funp [ptycon "complex" [], @tbool]))
              (combp
                (constp "complex_of_real"
                        (@funp [@treal, ptycon "complex" []]))
                (combp
                  (constp "real_of_num" (@funp [@tnum, @treal]))
                  @num0))))
          (elaborate
            (absp (typing (varp "x" (uty "t"))
                          (@funp [@tcon "complex", @tbool]))
              (combp (varp "x" (uty "t")) (@tvar "0"))))
      ]
    ))
  ].
