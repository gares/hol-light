%%% ===========================================================================
%%% Simple example of classical prover with iterative deepening.
%%% ===========================================================================

pred memb_and_rest o:A, o:list A, o:list A.

memb_and_rest A [A|L] L.
memb_and_rest A [B|L] [B|K] :- memb_and_rest A L K.

pred memb o:A, o:list A.

memb A [A|_].
memb A [_|As] :- memb A As.

%% ----------------------------------------------------------------------------
%% FOL formulas.
%% ----------------------------------------------------------------------------

kind form type.
kind i    type.

type and, or, imp       form -> form -> form.
type forall, exists     (i -> form) -> form.
type bottom             form.

infixl or  4.
infixl and 5.
infixr imp 6.

already_in_gamma L T :- std.exists L (same_term T).
already_in_delta L T :- std.exists L (same_term T).

%% ----------------------------------------------------------------------------
%% Sequents.
%% ----------------------------------------------------------------------------

kind  seq   type.
type  -->   list form -> list form -> seq.
infix -->   3.

%% ----------------------------------------------------------------------------
%% Proofs.
%% ----------------------------------------------------------------------------

kind  proof     type.

type  ex-falso  proof.
type  initial   form -> proof.

type  and_l     form -> proof -> proof.
type  and_r     form -> proof -> proof -> proof.

type  or_l      form -> proof -> proof -> proof.
type  or_r      form -> proof -> proof.

type  imp_l     form -> proof -> proof -> proof.
type  imp_r     form -> proof -> proof.

type  forall_r  form -> (i -> proof) -> proof.
type  exists_l  form -> (i -> proof) -> proof.

type  forall_l  form -> proof -> proof.
type  exists_r  form -> proof -> proof.

%% ----------------------------------------------------------------------------
%% Proof search algorithm.
%% ----------------------------------------------------------------------------

macro @cut-if P :- sigma Cut\ (if P (Cut = !) (Cut = true)), Cut.
% macro @cut-if P :- !.

kind solution type.
type unique solution.
type choice solution.

pred trivial o:proof, i:Seq, o:solution.
trivial P (Gamma --> Delta) S :-
  if (memb bottom Gamma)
     (P = ex-falso, S = unique)
     (trivial.aux P Gamma Delta Delta S).

:index(_ 1)
pred trivial.aux o:proof, i:list form, i:list form, i:list form, o:solution.

trivial.aux P [Hyp|Hyps] [G|Gs] OrigGoals S :-
  if (same_term Hyp G)
     (P = initial G, S = unique)
  (if (Hyp = G)
      (P = initial G, S = choice)
      (trivial.aux P [Hyp|Hyps] Gs OrigGoals S)).

trivial.aux P [_|Hyps] [] OrigGoals S :- !,
  trivial.aux P Hyps OrigGoals OrigGoals S.

pred invertible i:int, o:proof, i:seq, o:solution.
:if "DBG:SEARCH"
invertible N _ Seq _ :- print "invertible" N Seq, fail.

invertible N P (Gamma --> Delta) S :-
  invertible_l Gamma [] Delta [] N P S.

:index(2)
pred invertible_l i:list form, i:list form, i:list form, i:list form, i:int, o:proof, o:solution.
invertible_l [] Gamma Delta AccD N P S :- !,
  invertible_r Delta AccD [] Gamma N P S.

invertible_l [(A and B)|Gamma] Acc Delta AccD N (and_l (A and B) Q) S :- !,
  invertible_l [A,B|Gamma] Acc Delta AccD N Q S.

invertible_l [exists Ax|Gamma] Acc Delta AccD N (exists_l (exists Ax) Q) S :- !,
  pi x\ invertible_l [Ax x|Gamma] Acc Delta AccD N (Q x) S.

invertible_l [forall Ax|Gamma] Acc Delta AccD N (forall_l (forall Ax) Q) S :- !,
  if (already_in_gamma Acc (forall Ax)) (Acc1 = Acc) (Acc1 = [forall Ax|Acc]),
  sigma X\ invertible_l [Ax X|Gamma] Acc1 Delta AccD N Q S.

invertible_l [X|Gamma] Acc Delta AccD N P S :-
  invertible_l Gamma [X|Acc] Delta AccD N P S.

trivial-or-search _ P Seq S :-
  trivial P Seq S, @cut-if (S = unique).
trivial-or-search N P ((Gamma --> Delta) as Seq) S :-
  search N P Seq {std.length Gamma} {std.length Delta} S.

:index (2)
pred invertible_r i:list form, i:list form, i:list form, i:list form, i:int, o:proof, o:solution.
invertible_r [] Delta [] Gamma N P S :- !,
  Seq = ({std.rev Gamma} --> {std.rev Delta}),
  trivial-or-search N P Seq S.

invertible_r [] Delta Gamma AccG N P S :- !,
  invertible_l Gamma AccG [] Delta N P S.

invertible_r [forall Ax|Delta] Acc Gamma AccG N (forall_r (forall Ax) Q) S :- !,
  pi x\ invertible_r [Ax x|Delta] Acc Gamma AccG N (Q x) S.

invertible_r [(A imp B)|Delta] Acc Gamma AccG N (imp_r (A imp B) Q) S :- !,
  if (already_in_delta Delta B)       (D1 = Delta) (D1 = [B|Delta]),
  if (already_in_delta Acc (A imp B)) (Acc1 = Acc) (Acc1 = [(A imp B)|Acc]),
  if (already_in_gamma Gamma A)       (G1 = Gamma) (G1 = [A|Gamma]),
  invertible_r D1 Acc1 G1 AccG N Q S.

invertible_r [(A or B)|Delta] Acc Gamma AccG N (or_r (A or B) Q) S :- !,
  invertible_r [A,B|Delta] Acc Gamma AccG N Q S.

invertible_r [(exists Ax)|Delta] Acc Gamma AccG N (exists_r (exists Ax) Q) S :- !,
  sigma X\ invertible_r [Ax X|Delta] [exists Ax|Acc] Gamma AccG N Q S.

invertible_r [X|Delta] Acc Gamma AccG N P S :- !,
  invertible_r Delta [X|Acc] Gamma AccG N P S.


and-solution unique unique unique :- !.
and-solution _ _ choice.

pred search i:int, o:proof, i:seq, i:int, i:int, o:solution.

:if "DBG:SEARCH"
search Depth _ Seq _ _ _ :-
  print "search" Depth Seq,
  fail.

search N _P _Seq _ _ _ :-
    N < 0, !,
    fail.

search N (and_r (B and C) P Q) (Gamma --> [(B and C)|Delta]) _ _ S :-
    not(already_in_delta Delta B),
    not(already_in_delta Delta C),
    M is N - 1,
    (invertible M P (Gamma --> [B|Delta]) S1),
    @cut-if (S1 = unique),
    (invertible M Q (Gamma --> [C|Delta]) S2),
    and-solution S1 S2 S.

search N P (Gamma --> [F|Delta]) V  U S :- U > 0, !,
    std.append Delta [F] Delta1,
    search N P (Gamma --> Delta1) V {calc (U - 1)} S.


search N (or_l (B or C) P Q) ([(B or C)|Gamma] --> Delta) _ _ S :-
    not (already_in_gamma Gamma B ; already_in_gamma Gamma C),
    M is N - 1, 
    invertible M P ([B|Gamma] --> Delta) S1,
    @cut-if (S1 = unique),
    invertible M Q ([C|Gamma] --> Delta) S2,
    and-solution S1 S2 S.

search N (imp_l (B imp C) P Q) ([(B imp C)|Gamma] --> Delta) _ _ S :-
    not (already_in_gamma Gamma C),
    M is N - 1,
    (invertible M Q ([C,(B imp C)|Gamma] --> Delta)) S1,
    @cut-if (S1 = unique),
    (invertible M P ([(B imp C)|Gamma] --> [B])) S2,
    and-solution S1 S2 S.

search N P ([F|Gamma] --> Delta) V 0 S :- V > 0, !,
    std.append Gamma [F] Gamma1,
    search N P (Gamma1 --> Delta) {calc (V - 1)} 0 S.

search N P Seq 0 0 S :- !,
  M is N - 1,
  invertible M P Seq S.


%% Iterative deepening.

pred max-depth o:int.

pred deepen i:int, o:proof, i:seq, i:float.
deepen N _P _Seq T0 :- max-depth Max, N > Max, !,
                   print "Maximum search deepth excedeed after" {calc ({gettimeofday} - T0)},
                   fail.

deepen N P Seq T0 :- print "(Re)Start search at depth" N "after" {calc ({gettimeofday} - T0)},
                   invertible N P Seq S_.

deepen N P Seq T0 :- M is N + 1,
                   deepen M P Seq T0.

pred classical o:proof, i:Seq.

classical P Seq :- deepen 0 P Seq {gettimeofday}.

%% ----------------------------------------------------------------------------
%% Some tests.
%% ----------------------------------------------------------------------------

%% Term constructors.
type f, g     i -> i.
type c        i.

%% Form constructors.
type a        form.
type p, q, d  i -> form.

type p1, q1, r i -> i -> form.

type parent   i -> i -> form.
type ancestor i -> i -> form.

macro @iff A B :- ( (A imp B) and (B imp A) ).
macro @neg A   :- ( A imp bottom ).
macro @truth   :- ( @neg bottom ).

main :-
    Tests =
      [
        ( a imp a )
      , ( bottom imp a )
      , ( ((a imp bottom) imp a) imp a )
      , ( a or (a imp bottom) )
      , ( forall x\ d x imp exists y\ d y )
      , ( exists x\ d x imp forall y\ d y )
      , ( (forall x\ (d x)) imp @neg (exists y\ @neg (d y)) )
      , ( (exists x\ d x) imp (exists y\ d y or p y) )
      , ( @neg (forall x\ d x) imp (exists y\ @neg (d y)) )
      , ( @neg (exists x\ d x) imp (forall y\ @neg (d y)) )
      , ( (exists y\ @neg (d y)) imp @neg (forall x\ d x) )
      , ( (forall y\ @neg (d y)) imp @neg (exists x\ d x) )
      , ( ((forall x\ p x imp d x) and p c) imp d c )
      , (
          ( (forall x\ ancestor x x) and
            (forall x\ forall y\ forall z\
              parent x y and ancestor y z imp ancestor x z) )
          imp
          (forall a\ forall b\ forall c\
            (parent a b and parent b c) imp ancestor a c)
        )
      , (
          ( (forall x\ ancestor x x) and
            (forall x\ forall y\ forall z\
              parent x y and ancestor y z imp ancestor x z) )
          imp
          (forall a\ forall b\ forall c\ forall d\ forall e\
            (parent a d and
             parent a b and
             parent d e and
             parent b c
            ) imp ancestor a c)
        )
      %% Examples from Harrison's tutorial.
      , (
          (
            (@neg Input_a imp (@iff Internal (@neg bottom))) and
            (@neg Input_b imp (@iff Output Internal)) and
            (Input_a imp (@iff Output bottom)) and
            (Input_b imp (@iff Output bottom))
          ) imp (
            @iff Output (@neg (Input_a or Input_b))
          )
        )
      , (
          (
            (@iff (I1 and I2) A) and
            (@iff (I1 and I3) B) and
            (@iff (I2 and I3) C) and
            (@iff (I1 and  C) D) and
            (@iff (M  and  R) E) and
            (@iff (M  and  W) F) and
            (@iff (N  and  W) G) and
            (@iff (P  and  W) H) and
            (@iff (Q  and  W) I) and
            (@iff (S  and  X) J) and
            (@iff (T  and  X) K) and
            (@iff (V  and  X) L) and
            (@iff (I1 or  I2) M) and
            (@iff (I1 or  I3) N) and
            (@iff (I1 or   Q) P) and
            (@iff (I2 or  I3) Q) and
            (@iff (I3 or   A) R) and
            (@iff (a  or   W) S) and
            (@iff (B  or   W) T) and
            (@iff (D  or   H) U) and
            (@iff (C  or   W) V) and
            (@iff (@neg E) W) and
            (@iff (@neg U) X) and
            (@iff (I or L) O1) and
            (@iff (G or K) O2) and
            (@iff (F or J) O3)
          ) imp (
            (@iff O1 (@neg I1)) and
            (@iff O2 (@neg I2)) and
            (@iff O3 (@neg I3))
          )
        )
      , (
          ( 
            (forall x\ forall y\ forall z\ p1 x y and p1 y z imp p1 x z) and
            (forall x\ forall y\ forall z\ q1 x y and q1 y z imp q1 x z) and
            (forall x\ forall y\ p1 x y imp p1 y x) and
            (forall x\ forall y\ p1 x y or q1 x y)
          ) imp (
            (forall x\ forall y\ p1 x y) or (forall x\ forall y\ q1 x y)
          )
        )
      % These last twos do not work :-(
      /*
      , (
          (
            (forall x\ r x x) and
            (forall x\ forall y\ forall z\ (r x y and r y z) imp r x z) and
            (forall x\ forall y\ @iff (r (f x) y) (r x (g y)))
          ) imp (
            (forall x\ forall y\ r x y imp r (f x) (f y)) and
            (forall x\ forall y\ r x y imp r (g x) (g y))
          )
        )
      ,
        (
          @iff
            (@iff (exists x\ forall y\ @iff (p x) (p y))
                  (@iff (exists x\ q x) (forall y\ q y)))
            (@iff (exists x\ forall y\ @iff (q x) (q y))
                  (@iff (exists x\ (p x)) (forall y\ p y)))
        )
      */
      ],
    std.forall Tests test1.