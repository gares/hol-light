%%% ===========================================================================
%%% Type inference and term reconstruction.
%%%
%%% An experiment using continuation-passing style.
%%% ===========================================================================

%% ----------------------------------------------------------------------------
%% Handy macros for building pretypes and preterms.
%% ----------------------------------------------------------------------------

% Types.
macro @con A :- ptycon A [].
macro @bool  :- @con  "bool".
macro @num   :- @con  "num".
macro @ind   :- @con  "ind".
macro @dty   :- ptycon  "" [].
macro @fun A B :- ptycon  "fun" [A, B].
macro @fun2 A B C :- @fun A (@fun B C).

% Terms.
macro @binop Op X Y :- combp (combp Op X) Y.

%% ----------------------------------------------------------------------------
%% Entrypoint.
%% ----------------------------------------------------------------------------

pred elaborate i:preterm, o:preterm.
elaborate X Y :- infer X Y _A true.

%% ----------------------------------------------------------------------------
%% Main inference predicate.
%%
%%   infer X Y A K.
%%
%% Where:
%%   X = input (parsed) term;
%%   Y = output (inferred) term;
%%   A = inferred type;
%%   K = continuation.
%% ----------------------------------------------------------------------------

pred infer i:preterm, o:preterm, o:pretype, i:prop.

%% ----------------------------------------------------------------------------
%% Variable name convention:
%% A, B, C pretypes;
%%       D dummy pretype;
%%       V preterm variable;
%%    X, F arbitrary preterms;
%%       S string (name of variable or constant).
%% ----------------------------------------------------------------------------

%%% Variables.

infer (varp S _) X A K :-
    vinfer S X A,
    if (X = varp _ _)
       ((vinfer S X A :- !) => K)
       K.

%%% Combinations.

infer (combp F X) (combp F1 X1) B K :-
  infer F F1 (@fun A B) (infer X X1 A K).

%%% Abstractions.

infer (absp (varp S _) X) (absp (varp S A) X1) (@fun A B) K :-
    !,
    ((vinfer S (varp S A) A :- !) => infer X X1 B true),
    K.

% % Generalized abstractions.
% infer (absp X Y) (combp GABS GFUN) FunTy K :-
%     FunTy = @fun A B,
%     GABS = constp "GABS" (@fun (@fun FunTy @bool) FunTy),
%     GFUN = absp FVAR Body,
%     FVAR = varp "f" FunTy,
%     GEQ = @binop (constp "GEQ" (@fun2 B B @bool))
%                  (combp FVAR X1)
%                  Y1,
%     infer X X1 A
%         ( frees X1 Vs,
%           list_pmk_forall Vs GEQ Body,
%           infer Y Y1 B true
%         ),
%     K.

%%% Type annotations.

infer (typing X A) X1 A K :- infer X X1 A K.

%%% Overloading.

pred vinfer i:string, o:preterm, o:pretype.
vinfer S X A :-
  overload S S1 C, refresh-cpretype C A, cinfer S1 X A
  ;
  not (overload S _ _), cinfer S X A.

%%% Constants.

pred cinfer i:string, o:preterm, o:pretype.
cinfer S (constp S A) A :- env S _ C, !, refresh-cpretype C A.
cinfer S (varp S A) A.

%% ----------------------------------------------------------------------------
%% Further macros.
%% ----------------------------------------------------------------------------

%% Type variables.
macro @aty :- uty  "A".
macro @bty :- uty  "B".

% Term variables.
macro @a :- varp "a" @dty.
macro @b :- varp "b" @dty.
macro @x :- varp "x" @dty.
macro @y :- varp "y" @dty.
macro @z :- varp "z" @dty.
macro @f :- varp "f" @dty.
macro @g :- varp "g" @dty.
macro @h :- varp "h" @dty.

% Simple terms.
macro @i S :- varp S @dty.

% Binary operators.
macro @eqvar X Y :- combp (combp (@i "eq") X) Y.
macro @pr X Y :- combp (combp (@i "pr") X) Y.

macro @eq A X Y :- @binop (constp "eq" (@fun2 A A @bool)) X Y.
macro @id A X :- combp (constp "id" (@fun A A)) X.

%% ----------------------------------------------------------------------------
%% Extend testing framework.
%% ----------------------------------------------------------------------------

shorten test.{ test, run-tests, run-test, success, failure,
               ok, ko, okb, kob, ok-eq, section }.
shorten verbosity.{ quiet, terse, info, verbose, debug, with-verbosity }.

type ok-elaborate preterm -> preterm -> test.
type ko-elaborate preterm -> test.

run-test (ok-elaborate X Y) Ret :-
  elaborate X Z, !,
  if (same_term Y Z)
     ( Ret = success "" )
     (
       Ret = failure Msg,
       Msg is "Success with wrong return vaule.\nExpected: " ^
              {term_to_string Y} ^ "\nReturned: " ^ {term_to_string Z}
     ).
run-test (ok-elaborate _ Y) (failure Msg) :-
  Msg is "Call failed.  Expected: " ^ {term_to_string Y}.
run-test (ko-elaborate X) (failure Msg) :- elaborate X Y, !,
  Msg is "Should fail.\nReturned: " ^ {term_to_string Y}.
run-test (ko-elaborate _) (success "").

%% ----------------------------------------------------------------------------
%% Tests.
%% ----------------------------------------------------------------------------

pred status o:list prop.
status
  [ env "a" "a" (ptybody @num)
  , env "b" "b" (ptybody @bool)
  , env "f" "f" (ptybody (@fun @num @num))
  , env "g" "g" (ptybody (@fun2 @num @bool @num))
  , env "id" "id" (ptyfree @aty A \ ptybody (@fun A A))
  , env "eq" "eq" (ptyfree @aty A \ ptybody (@fun2 A A @bool))
  , overload "z" "u" (ptybody (@fun @num @ind))
  , overload "z" "v" (ptybody (@fun @bool @ind))
  ].

pred infer_test.
infer_test :- status PP, PP => run-tests
  [ section "Elaborate"
  , ok-elaborate @a (constp "a" @num)
  , ok-elaborate (typing @x @bty) (varp "x" @bty)
  , ok-elaborate (combp @f @a)
      (combp (constp "f" (@fun @num @num)) (constp "a" @num))
  , ok-elaborate (typing (combp @h @a) @bool)
      (combp (varp "h" (@fun @num @bool)) (constp "a" @num))
  , ok-elaborate (combp @z @a)
      (combp (varp "u" (@fun @num @ind)) (constp "a" @num))
  , ok-elaborate (combp @z @b)
      (combp (varp "v" (@fun @bool @ind)) (constp "b" @bool))
  , ko-elaborate (combp @f @b)
  , ko-elaborate (combp @a @b)
  , ok-elaborate (combp @g @a)
      (combp (constp "g" (@fun2 @num @bool @num)) (constp "a" @num))
  , ko-elaborate (combp @g @b)
  , ok-elaborate (combp (@i "id") @a) (@id @num (constp "a" @num))
  , ok-elaborate (combp (@i "id") @b) (@id @bool (constp "b" @bool))
  , ok-elaborate (combp (@i "id") (typing @x @aty))
      (@id @aty (varp "x" @aty))
  , ok-elaborate (@eqvar @a @x) (@eq @num (constp "a" @num) (varp "x" @num))
  , ok-elaborate (typing (absp @x @x) (@fun @aty @aty))
      (absp (varp "x" @aty) (varp "x" @aty))
  , ok-elaborate (@eqvar (@i "id") (absp @x @a))
      (@eq (@fun @num @num)
           (constp "id" (@fun @num @num))
           (absp (varp "x" (@num)) (constp "a" (@num))))
  ].