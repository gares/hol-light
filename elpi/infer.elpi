%%% ===========================================================================
%%% Type inference and term reconstruction.
%%%
%%% An experiment using continuation-passing style.
%%% ===========================================================================

%% ----------------------------------------------------------------------------
%% Handy macros for building pretypes and preterms.
%% ----------------------------------------------------------------------------

% Types.
macro @dty :- ptycon "" [].
macro @bool :- ptycon "bool" [].
macro @con A :- ptycon A [].
macro @fun A B :- ptycon "fun" [A, B].
macro @fun2 A B C :- @fun A (@fun B C).

% Terms.
macro @binop Op X Y :- combp (combp Op X) Y.

%% ----------------------------------------------------------------------------
%% Entrypoint.
%% ----------------------------------------------------------------------------

pred elaborate i:preterm, o:preterm.
elaborate X Y :- infer X Y _A true.

%% ----------------------------------------------------------------------------
%% Main inference predicate.
%%
%%   infer X Y A K.
%%
%% Where:
%%   X = input (parsed) term;
%%   Y = output (inferred) term;
%%   A = inferred type;
%%   K = continuation.
%% ----------------------------------------------------------------------------

pred infer i:preterm, o:preterm, o:pretype, i:prop.

%% ----------------------------------------------------------------------------
%% Variable name convention:
%% A, B, C pretypes;
%%       D dummy pretype;
%%       V preterm variable;
%%    X, F arbitrary preterms;
%%       S string (name of variable or constant).
%% ----------------------------------------------------------------------------

%%% Variables.

infer (varp S _) X A K :-
    vinfer S X A,
    if (X = varp _ _)
       ((vinfer S X A :- !) => K)
       K.

%%% Combinations.

infer (combp F X) (combp F1 X1) B K :-
  infer F F1 (@fun A B) (infer X X1 A K).

%%% Abstractions.

infer (absp (varp S _) X) (absp (varp S A) X1) (@fun A B) K :-
    !,
    ((vinfer S X A :- !) => infer X X1 B true),
    K.

% % Generalized abstractions.
% infer (absp X Y) (combp GABS GFUN) FunTy K :-
%     FunTy = @fun A B,
%     GABS = constp "GABS" (@fun (@fun FunTy @bool) FunTy),
%     GFUN = absp FVAR Body,
%     FVAR = varp "f" FunTy,
%     GEQ = @binop (constp "GEQ" (@fun2 B B @bool))
%                  (combp FVAR X1)
%                  Y1,
%     infer X X1 A
%         ( frees X1 Vs,
%           list_pmk_forall Vs GEQ Body,
%           infer Y Y1 B true
%         ),
%     K.

%%% Type annotations.

infer (typing X A) X1 A K :- infer X X1 A K.

%%% Overloading.

pred vinfer i:string, o:preterm, o:pretype.
vinfer S X A :-
    overload S S1 C,
    refresh-cpretype C A, cinfer S1 X A
    ;
    not (overload S _ _), cinfer S X A.

%%% Constants.

pred cinfer i:string, o:preterm, o:pretype.
cinfer S (constp S A) A :- env S _ C, !, refresh-cpretype C A.
cinfer S (varp S A) A.

%% ----------------------------------------------------------------------------
%% Further macros.
%% ----------------------------------------------------------------------------

%% Constant types.
macro @num :- ptycon "num" [].
macro @ind :- ptycon "ind" [].

%% Type variables.
macro @aty :- uty "A".
macro @bty :- uty "B".

% Term variables.
macro @a :- varp "a" @dty.
macro @b :- varp "b" @dty.
macro @x :- varp "x" @dty.
macro @y :- varp "y" @dty.
macro @z :- varp "z" @dty.
macro @f :- varp "f" @dty.
macro @g :- varp "g" @dty.
macro @h :- varp "h" @dty.

% Simple terms.
macro @i S :- varp S @dty.

% Binary operators.
macro @eq X Y :- combp (combp (@i "eq") X) Y.
macro @pr X Y :- combp (combp (@i "pr") X) Y.

%% ----------------------------------------------------------------------------
%% Extend testing framework.
%% ----------------------------------------------------------------------------

shorten test.{ test, run-tests, run-test, success, failure,
               ok, ko, okb, kob, ok-eq, section }.
shorten verbosity.{ quiet, terse, info, verbose, debug, with-verbosity }.

type ok-elaborate preterm -> test.
type ko-elaborate preterm -> test.

run-test (ok-elaborate X) (success "") :- sigma Y \ elaborate X Y, !.
run-test (ok-elaborate _) (failure "Should success").
run-test (ko-elaborate X) (failure "Should fail") :- elaborate X _, !.
run-test (ko-elaborate _) (success "").

%% ----------------------------------------------------------------------------
%% Tests.
%% ----------------------------------------------------------------------------

pred status o:list prop.
status
  [ env "a" "a" (ptybody @num)
  , env "b" "b" (ptybody @bool)
  , env "f" "f" (ptybody (@fun @num @num))
  , env "g" "g" (ptybody (@fun2 @num @bool @num))
  , env "id" "id" (ptyfree (uty "A") A \ ptybody (@fun A A))
  , env "eq" "eq" (ptyfree (uty "A") A \ ptybody (@fun2 A A @bool))
  , overload "z" "u" (ptybody (@fun @num @ind))
  , overload "z" "v" (ptybody (@fun @bool @ind))
  ].

pred infer_test.
infer_test :- status PP, PP => run-tests
  [ section "Elaborate"
  , ok-elaborate @a
  , ok-elaborate @x
  , ok-elaborate (combp @f @a)
  , ok-elaborate (combp @h @a)
  , ok-elaborate (combp @z @a)
  , ok-elaborate (combp @z @b)
  , ko-elaborate (combp @f @b)
  , ko-elaborate (combp @a @b)
  , ok-elaborate (combp @g @a)
  , ko-elaborate (combp @g @b)
  , ok-elaborate (combp (@i "id") @a)
  , ok-elaborate (combp (@i "id") @b)
  , ok-elaborate (combp (@i "id") @x)
  , ok-elaborate (@eq @a @x)
  , ok-elaborate (absp @x @x)
  , ok-elaborate (@eq (@i "id") (absp @x @a))
  ].