%%% ===========================================================================
%%% Elaborator for type inference and term reconstruction.
%%%
%%% Needs pre_hol.elpi.
%%% ===========================================================================

%% ----------------------------------------------------------------------------
%% Handy macros.
%% ----------------------------------------------------------------------------

macro @dummy :- ptycon "" [].
macro @fun L :- ptycon "fun" L.
macro @con X :- ptycon X [].

macro @bool    :- @con "bool".
macro @num     :- @con "num".
macro @real    :- @con "real".
macro @complex :- @con "complex".

macro @var S :- varp S @dummy.

%% ----------------------------------------------------------------------------
%% entrypoint
%% ----------------------------------------------------------------------------

pred elab i:preterm, o:preterm.

%% ----------------------------------------------------------------------------
%% open dependencies
%% ----------------------------------------------------------------------------

% HOL-light coercion
kind coercion type.
type coercion string -> cpretype -> coercion.

pred coercions o:list coercion. % DB

%% ----------------------------------------------------------------------------
%% main
%% ----------------------------------------------------------------------------

shorten verbosity.{ quiet, terse, info, verbose, debug, when-verbosity }.

elab T R :-
  % we assume a SINGLE type for each free variable
  free-vars T [] VS, std.map VS build-clause-fv VST, (VST =>
   (
    % we try with no coercions
    ((coercions [] :- !) => of T TY R)
     ;
    % we try again with coercions
    (of T TY R)
   )
  ),
  when-verbosity debug (print VS "|-" T "\n-e->\n" R ":" TY).

pred build-clause-fv i:preterm, o:prop.

build-clause-fv (varp S _) (of (varp S _) Ty (varp S Ty) :- !).
 
%% ----------------------------------------------------------------------------
%% typing
%% ----------------------------------------------------------------------------

pred of o:preterm, o:pretype, o:preterm.

:name "of:constant"
of (varp S DTY) TY T :-
  overload S S1 CTY,
  refresh-cpretype CTY TY,
  (overload _ _ _ :- !, fail) => of (varp S1 DTY) TY T.
of (varp S _) (@con "num") N :- numeral S N, !.
of (varp S _) TY (constp S TY) :- env S S CTY, refresh-cpretype CTY TY.

pred is_varp o:string, o:pretype.

:name "of:abstraction"
of (absp (varp S D) F) (@fun [Src,Tgt]) (absp (varp S Src) F1) :-
  is_varp S Src =>
  (of (varp S D) Src (varp S Src) :- !) =>
    of F Tgt F1.
of (absp (typing (varp S D) Src) F) (@fun [Src,Tgt]) (absp (varp S Src) F1) :-
  is_varp S Src =>
  (of (varp S D) Src (varp S Src) :- !) =>
    of F Tgt F1.

:name "of:application"
of (combp A B) Tgt (combp A1 B1) :-
  of A (@fun [Src,Tgt]) A1,
  of-coerce B Src B1.
of (typing T TY) TY T1 :-
  of-coerce T TY T1.

%% ----------------------------------------------------------------------------
%% coercing
%% ----------------------------------------------------------------------------

% like of, but can cast the term inserting a coercion
pred of-coerce i:preterm, o:pretype, o:preterm.

of-coerce A T R :-
  /*report-all-failures-if-no-success*/ (
  of A T1 R1,
  (
    (trans-coercion T1 T R1 R) 
  /*
    ( Msg is "error"/*"The term\n\t" ^ {hol.term->string R1} ^
             "\nhas type\n\t" ^ {hol.ty->string T1} ^
             "\nthat is not\n\t" ^ {hol.ty->string T}*/,
       error [ Msg ]
    )*/
  )
  ).
/*
stash-new E S :- open_safe E L, ( std.mem L S ; stash_in_safe E S ), !.

report-all-failures-if-no-success P :-
  new_safe E,
  (((pi ML\ error ML :- !, std.forall ML (stash-new E), fail) => P)
   ;
   (error {open_safe E})).

error L :- std.forall L (x\ print "Error:" x), fail.
*/

pred trans-coercion o:pretype, o:pretype, o:preterm, o:preterm.
%% TODO: The notation == for same_term does work in the embedded interpreter,
%% but does not work in the elpi toplevel.
trans-coercion X X1 T T :- same_term X X1, !.
trans-coercion X X T T.
trans-coercion A B T R1 :-
  coercions Coercions,
  %print "looking for a coercion" A "->" B "for" T,
  std.mem Coercions (coercion S TS),
  %print "attempt" S ":" TS,
  refresh-cpretype TS (@fun [A, A1]),
  trans-coercion A1 B (combp (constp S (@fun [A, A1])) T) R1.

%% ----------------------------------------------------------------------------
%% Tests.
%% ----------------------------------------------------------------------------

pred tiny_env o:list prop.
tiny_env
  [ env "0" "0" (ptybody @num)
  , env "real_of_num" "real_of_num" (ptybody (@fun [@num, @real]))
  , env "complex_of_real" "complex_of_real" (ptybody (@fun [@real, @complex]))
  , coercions [coercion "real_of_num" (ptybody (@fun [@num, @real]))]
  ].

pred small_env o:list prop.
small_env
  [ env "0" "0" (ptybody @num)
  , env "real_of_num" "real_of_num" (ptybody (@fun [@num, @real]))
  , env "complex_of_real" "complex_of_real" (ptybody (@fun [@real, @complex]))
  , coercions
    [ coercion "real_of_num"     (ptybody (@fun [@num,  @real]))
    , coercion "complex_of_real" (ptybody (@fun [@real, @complex]))
    ]
  ].

shorten test.{ run-tests, ok, ko, okb, kob, ok-eq, section }.

pred elab_tests.
elab_tests :-
  tiny_env TinyEnv,
  TinyEnv => run-tests
  [ section "close-term"
  , ok-eq
      (ptmfree (varp "y" (uty "t")) Y \
        ptmbody (lamp (varp "x" (@con "1")) X \
          combp Y (combp X (constp "0" @dummy))))
      (close-term
        (absp (varp "x" (uty "t"))
          (combp (varp "y" (uty "t"))
            (combp (varp "x" (uty "t")) (@var "0")))))
  , ok-eq
      (ptmfree (varp "y" (uty "t")) Y \
        ptmbody (lamp (varp "x" (uty "t")) X \
          combp Y (combp X (constp "0" @dummy))))
      (close-term
        (absp (varp "x" (uty "t"))
          (combp (varp "y" (uty "t"))
            (combp (varp "x" (uty "t")) (@var "0")))))
  , section "elab"
  , ok-eq
      (absp (varp "x" (@fun [@num, @con "1"]))
        (combp (varp "y" (@fun [@con "1", @con "2"])) 
          (combp (varp "x" (@fun [@num, @con "1"])) 
            (constp "0" @num))))
      (elab (absp (varp "x" (uty "t"))
        (combp (varp "y" (uty "t"))
          (combp (varp "x" (uty "t")) (@var "0")))))
  , section "elab w/ coercions"
  , ok-eq
      (absp (varp "x" (@fun [@real, @bool])) 
        (combp (varp "y" (@fun [@bool, @con "1"])) 
          (combp (varp "x" (@fun [@real, @bool])) 
            (combp
              (constp "real_of_num" (@fun [@num, @real])) 
              (constp "0" @num)))))
      (elab
        (absp (typing (varp "x" (uty "t")) (@fun [@real, @bool]))
          (combp (varp "y" (uty "t"))
            (combp (varp "x" (uty "t")) (@var "0")))))
  ],
  small_env SmallEnv,
  SmallEnv => run-tests
  [ section "elab2"
  , ok-eq
      (absp (varp "x" (@fun [ptycon "complex" [], @bool])) 
        (combp (varp "x" (@fun [ptycon "complex" [], @bool])) 
          (combp
            (constp "complex_of_real" (@fun [@real, ptycon "complex" []]))
            (combp
              (constp "real_of_num" (@fun [@num, @real])) 
              (constp "0" @num)))))
      (elab
        (absp (typing (varp "x" (uty "t")) (@fun [@con "complex", @bool]))
          (combp (varp "x" (uty "t")) (@var "0"))))
  ].
