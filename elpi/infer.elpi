%%% ===========================================================================
%%% Type inference and term reconstruction.
%%%
%%% An experiment using continuation-passing style.
%%% ===========================================================================

%% ----------------------------------------------------------------------------
%% Handy macros for building pretypes and preterms.
%% ----------------------------------------------------------------------------

% Types.
macro @tcon A :- ptycon A [].
macro @tbool  :- @tcon  "bool".
macro @tnum   :- @tcon  "num".
macro @tind   :- @tcon  "ind".
macro @tdty   :- ptycon  "" [].
macro @tfun A B :- ptycon  "fun" [A, B].
macro @funp L :- ptycon  "fun" L.
macro @tfun2 A B C :- @tfun A (@tfun B C).

% Terms.
macro @tbinop Op X Y :- combp (combp Op X) Y.

%% ----------------------------------------------------------------------------
%% Entrypoint.
%% ----------------------------------------------------------------------------

pred elaborate i:preterm, o:preterm.
elaborate X Y :- infer X Y _A true.

%% ----------------------------------------------------------------------------
%% Main inference predicate.
%%
%%   infer X Y A K.
%%
%% Where:
%%   X = input (parsed) term;
%%   Y = output (inferred) term;
%%   A = inferred type;
%%   K = continuation.
%% ----------------------------------------------------------------------------

pred infer i:preterm, o:preterm, o:pretype, i:prop.

%% ----------------------------------------------------------------------------
%% Variable name convention:
%% A, B, C pretypes;
%%       D dummy pretype;
%%       V preterm variable;
%%    X, F arbitrary preterms;
%%       S string (name of variable or constant).
%% ----------------------------------------------------------------------------

%%% Variables.

infer (varp S _) X A K :-
    vinfer S X A,
    if (X = varp _ _)
       ((vinfer-free S X A :- !) => K)
       K.

%%% Combinations.

infer (combp F X) (combp F1 X1) B K :-
  infer F F1 (@tfun A B) (infer X X1 A K).

%%% Abstractions.

infer (absp (varp S _) X) (absp (varp S A) X1) (@tfun A B) K :-
  !,
  ((vinfer-free S (varp S A) A :- !) => infer X X1 B true),
  K.

macro @geq A X Y :- @tbinop (constp "GEQ" (@tfun2 A A @tbool)) X Y.
macro @gabs A B X :-
  combp (constp "GABS" (@tfun (@tfun (@tfun A B) @tbool) (@tfun A B))) X.

%%% Generalized abstractions.
%%% Simplified version: concrete syntax of generalized abstraction is
%%% delegated to the HOL library function term_of_preterm.
infer (absp X Y) (absp X1 Y1) (@tfun A B) K :-
  infer X X1 A true,
  frees X1 Vs,
  (vinfer-free S (varp S A) A :- std.mem! Vs (varp S A), !)
  => infer Y Y1 B true,
  K.

%%% Version that produces the concrete form of the generalized abstraction.
% infer (absp X Y) Z (@tfun A B) K :-
%   infer X X1 A true,
%   frees X1 Vs,
%   (vinfer-free S (varp S A) A :- std.mem! Vs (varp S A), !)
%   => infer Y Y1 B true,
%   pmk_gabs A B Vs X1 Y1 Z,
%   K.

pred pmk_gabs i:pretype, i:pretype, i:list preterm,
              i:preterm, i:preterm, o:preterm.
pmk_gabs _ _ _ (varp _ _ as V) X (absp V X) :- !.
pmk_gabs A B Vs X Y (@gabs A B (absp F Z)) :-
  F = varp "f" (@tfun A B),
  list_pmk_forall Vs (@geq B (combp F X) Y) Z.

%%% Type annotations.

infer (typing X A) X1 A K :- infer X X1 A K.

%%% Free variables.

pred vinfer-free i:string, o:preterm, o:pretype.

%%% Overloading.

pred vinfer i:string, o:preterm, o:pretype.
vinfer S V A :- vinfer-free S V A, !.
vinfer S X A :-
  overload S S1 C, refresh-cpretype C A, cinfer S1 X A
  ;
  not (overload S _ _), cinfer S X A.

%%% Constants.

pred cinfer i:string, o:preterm, o:pretype.
cinfer S (constp S A) A :- env S _ C, !, refresh-cpretype C A.
cinfer S (varp S A) A.

%% ----------------------------------------------------------------------------
%% Further macros.
%% ----------------------------------------------------------------------------

%% Type variables.
macro @aty :- uty  "A".
macro @bty :- uty  "B".

% Term variables.
macro @a :- varp "a" @tdty.
macro @b :- varp "b" @tdty.
macro @x :- varp "x" @tdty.
macro @y :- varp "y" @tdty.
macro @z :- varp "z" @tdty.
macro @f :- varp "f" @tdty.
macro @g :- varp "g" @tdty.
macro @h :- varp "h" @tdty.

% Simple terms.
macro @i S :- varp S @tdty.

% Binary operators.
macro @eqvar X Y :- combp (combp (@i "eq") X) Y.
macro @pr X Y :- combp (combp (@i "pr") X) Y.

macro @eq A X Y :- @tbinop (constp "eq" (@tfun2 A A @tbool)) X Y.
macro @id A X :- combp (constp "id" (@tfun A A)) X.

%% ----------------------------------------------------------------------------
%% Extend testing framework.
%% ----------------------------------------------------------------------------

shorten test.{ test, run-tests, run-test, success, failure,
               ok, ko, okb, kob, ok-eq, section }.
shorten verbosity.{ quiet, terse, info, verbose, debug, with-verbosity }.

type ok-elaborate preterm -> preterm -> test.
type ko-elaborate preterm -> test.

run-test (ok-elaborate X Y) Ret :-
  infer X Z A true, !,
  if (same_term Y Z)
    (
      if (has_type Z A1)
        (
          if (same_term A A1)
            ( Ret = success "" )
            ( Ret = failure "Wrong type" )
        ) (
          Msg is "Malformed term (has_type fails)\n" ^
                 {term_to_string X} ^ "\n-->\n" ^ {term_to_string Z},
          Ret = failure Msg
        )
    ) (
      Ret = failure Msg,
      Msg is "Success with wrong return vaule.\nExpected: " ^
             {term_to_string Y} ^ "\nReturned: " ^ {term_to_string Z}
    ).
run-test (ok-elaborate _ Y) (failure Msg) :-
  Msg is "Call failed.  Expected: " ^ {term_to_string Y}.
run-test (ko-elaborate X) (failure Msg) :- elaborate X Y, !,
  Msg is "Should fail.\nReturned: " ^ {term_to_string Y}.
run-test (ko-elaborate _) (success "").

%% ----------------------------------------------------------------------------
%% Tests.
%% ----------------------------------------------------------------------------

pred status o:list prop.
status
  [ env "a" "a" (ptybody @tnum)
  , env "b" "b" (ptybody @tbool)
  , env "f" "f" (ptybody (@tfun @tnum @tnum))
  , env "g" "g" (ptybody (@tfun2 @tnum @tbool @tnum))
  , env "id" "id" (ptyfree @aty A \ ptybody (@tfun A A))
  , env "eq" "eq" (ptyfree @aty A \ ptybody (@tfun2 A A @tbool))
  , overload "z" "u" (ptybody (@tfun @tnum @tind))
  , overload "z" "v" (ptybody (@tfun @tbool @tind))
  ].

pred infer_test.
infer_test :- status PP, PP => run-tests
  [ section "has_type"
  , ok-eq (@tfun @tbool @tnum)
      (has_type
        (@gabs @tbool @tnum
          (varp "u" (@tfun (@tfun @tbool @tnum) @tbool))))
  , ok-eq @tbool
      (has_type (@geq @tbool (varp "x" @tbool) (varp "x" @tbool)))
  , section "pmk_gabs"
  , ok-eq
      (combp
        (constp "GABS"
          (@funp [@funp [@tfun @tnum @tnum, @tbool], @tfun @tnum @tnum]))
        (absp (varp "f" (@tfun @tnum @tnum))
          (combp
            (constp "!" (@funp [@funp [@tnum, @tbool], @tbool]))
            (absp (varp "m" @tnum)
              (combp
                (constp "!" (@funp [@funp [@tfun @tnum @tnum, @tbool], @tbool]))
                (absp (varp "s" (@tfun @tnum @tnum))
                  (combp
                    (combp
                      (constp "GEQ" (@funp [@tnum, @funp [@tnum, @tbool]]))
                      (combp
                        (varp "f" (@tfun @tnum @tnum))
                        (combp (varp "s" (@tfun @tnum @tnum))
                          (varp "m" @tnum)))) (varp "x" @tnum))))))))
      (pmk_gabs @tnum @tnum [varp "m" @tnum, varp "s" (@tfun @tnum @tnum)]
        (combp (varp "s" (@tfun @tnum @tnum))
               (varp "m" @tnum))
        (varp "x" @tnum))
  , section "Elaborate"
  , ok-elaborate @a (constp "a" @tnum)
  , ok-elaborate (typing @x @bty) (varp "x" @bty)
  , ok-elaborate (combp @f @a)
      (combp (constp "f" (@tfun @tnum @tnum)) (constp "a" @tnum))
  , ok-elaborate (typing (combp @h @a) @tbool)
      (combp (varp "h" (@tfun @tnum @tbool)) (constp "a" @tnum))
  , ok-elaborate (combp @z @a)
      (combp (varp "u" (@tfun @tnum @tind)) (constp "a" @tnum))
  , ok-elaborate (combp @z @b)
      (combp (varp "v" (@tfun @tbool @tind)) (constp "b" @tbool))
  , ko-elaborate (combp @f @b)
  , ko-elaborate (combp @a @b)
  , ok-elaborate (combp @g @a)
      (combp (constp "g" (@tfun2 @tnum @tbool @tnum)) (constp "a" @tnum))
  , ko-elaborate (combp @g @b)
  , ok-elaborate (combp (@i "id") @a) (@id @tnum (constp "a" @tnum))
  , ok-elaborate (combp (@i "id") @b) (@id @tbool (constp "b" @tbool))
  , ok-elaborate (combp (@i "id") (typing @x @aty))
      (@id @aty (varp "x" @aty))
  , ok-elaborate (@eqvar @a @x) (@eq @tnum (constp "a" @tnum) (varp "x" @tnum))
  , ok-elaborate (typing (absp @x @x) (@tfun @aty @aty))
      (absp (varp "x" @aty) (varp "x" @aty))
  , ok-elaborate (@eqvar (@i "id") (absp @x @a))
      (@eq (@tfun @tnum @tnum)
           (constp "id" (@tfun @tnum @tnum))
           (absp (varp "x" @tnum) (constp "a" @tnum)))
  , ok-elaborate (absp (combp @f @x) @x)
      (combp
        (constp "GABS"
          (ptycon "fun"
            [@funp [(@tfun @tnum @tnum), @tbool],
             (@tfun @tnum @tnum)]))
        (absp
          (varp "f" (@tfun @tnum @tnum))
          (combp
            (constp "!"
              (ptycon "fun"
                [@funp [@tnum, @tbool], @tbool]))
            (absp (varp "x" @tnum)
              (combp
                (combp
                  (constp "GEQ"
                    (ptycon "fun"
                      [@tnum, @funp [@tnum, @tbool]]))
                  (combp
                    (varp "f" (@tfun @tnum @tnum))
                    (combp (constp "f" ((@tfun @tnum @tnum)))
                      (varp "x" @tnum)))) (varp "x" @tnum))))))
  ].