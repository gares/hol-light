%%% ===========================================================================
%%% lProlog code needed for HOL-Elpi that do not depend on Hol or ML.
%%% ===========================================================================

%% ----------------------------------------------------------------------------
%% The type of pretypes.
%% ----------------------------------------------------------------------------

kind pretype type.

type uty      string -> pretype.                     % User type variable
type ptycon   string -> list pretype -> pretype.     % Type constructor
type sty      int -> pretype.                        % System type variable

%% ----------------------------------------------------------------------------
%% The of closed pretypes.
%% The first argument of ptyfree is for storing the type variable.
%% ----------------------------------------------------------------------------

kind cpretype type.

type ptybody  pretype -> cpretype.                   % Body
type ptyfree  pretype ->                             % Type variable binder
                (pretype -> cpretype) -> cpretype.

%% ----------------------------------------------------------------------------
%% Copy clauses for the pretype datatype.
%% ----------------------------------------------------------------------------

pred ptycopy i:pretype, o:pretype.

ptycopy (uty _S as X) X.
ptycopy (sty _N as X) X.
ptycopy (ptycon S Ts) (ptycon S Rs) :- std.map Ts ptycopy Rs.
% since we may put refreshed schemas inside terms and since we copy
% types attached to constp/typingp and since this predicate is not
% generative we need to handle the case in which the input is flexible
% explicitly (`uvar` is a keyword)
ptycopy (uvar as X) X.

%% ----------------------------------------------------------------------------
%% Collecting the type variables occurring in a pretype.
%% Needed as a preliminary step for computing the cpretype of a pretype.
%% ----------------------------------------------------------------------------

pred ptyvars i:pretype, i:list pretype, o:list pretype.

ptyvars (uty _S as X) Vs Vs :- std.mem Vs X, !.
ptyvars (uty _S as X) Vs [X|Vs].
ptyvars (sty _N as X) Vs Vs :- std.mem Vs X, !.
ptyvars (sty _N as X) Vs [X|Vs].
ptyvars (ptycon _S Ts) Vs Ws :- ptyvars_list Ts Vs Ws.

pred ptyvars_list i:list pretype, i:list pretype, o:list pretype.

ptyvars_list [] Vs Vs.
ptyvars_list [T|Ts] Vs Ws :- ptyvars T Vs Us, ptyvars_list Ts Us Ws.

%% ----------------------------------------------------------------------------
%% Computing the closed pretype (cpretype) associated to a pretype.
%% ----------------------------------------------------------------------------

% Closure in a given context.
pred ptyclose i:list pretype, i:pretype, o:cpretype.

ptyclose [] T (ptybody P) :- ptycopy T P.
ptyclose [V|Vs] T (ptyfree V R) :-
  (pi v\ (ptycopy V v :- !) => ptyclose Vs T (R v)).

% The main predicate: Closure of a pretype.
pred close-pretype i:pretype, o:cpretype.

close-pretype P C :- ptyvars P [] Vs, ptyclose Vs P C.

pred refresh-cpretype i:cpretype, o:pretype.

refresh-cpretype (ptybody T) T.
refresh-cpretype (ptyfree _V F) T :- refresh-cpretype (F FRESH_) T.

%% ----------------------------------------------------------------------------
%% The type of preterms.
%% Notice the two abstractions (absp and lamp).
%% The first argument of lamp is for storing the variable.
%% ----------------------------------------------------------------------------

kind preterm type.

type varp    string -> pretype -> preterm.           % Variable
type constp  string -> pretype -> preterm.           % Constant
type combp   preterm -> preterm -> preterm.          % Combination
type typing  preterm -> pretype -> preterm.          % Typing
type absp    preterm -> preterm -> preterm.          % Abstraction
type lamp    preterm ->                              % HO Abstraction
               (preterm -> preterm) -> preterm.

%% ----------------------------------------------------------------------------
%% Copy clauses for the preterm datatype.
%% ----------------------------------------------------------------------------

pred ptmcopy i:preterm, o:preterm.

ptmcopy (varp _ _ as X) X.
ptmcopy (constp _ _ as X) X.
ptmcopy (combp X1 Y1) (combp X2 Y2)   :- ptmcopy X1 X2, ptmcopy Y1 Y2.
ptmcopy (typing X1 T1) (typing X2 T2) :- ptmcopy X1 X2, ptycopy T1 T2.
ptmcopy (absp V1 X1) (absp V2 X2)     :- ptmcopy V1 V2, ptmcopy X1 X2.
ptmcopy (lamp V B1) (lamp V B2) :-
  pi x\ ptmcopy x x => ptmcopy (B1 x) (B2 x).
ptmcopy (uvar as X) X.

%% ----------------------------------------------------------------------------
%% The of closed preterms.
%% The first argument of ptmbind is for storing the variable.
%% ----------------------------------------------------------------------------

kind cpreterm type.

type ptmbody  preterm -> cpreterm.                    % Body
type ptmfree  preterm ->                              % Variable binder
                (preterm -> cpreterm) -> cpreterm.

%% ----------------------------------------------------------------------------
%% Collecting the variables occurring in a preterm.
%% Needed as a preliminary step for computing the cpreterm of a preterm.
%% ----------------------------------------------------------------------------

pred ptmvars i:preterm, i:list preterm, o:list preterm.

ptmvars (varp _ _ as X) Vs Vs :- std.mem Vs X, !.
ptmvars (varp _ _ as X) Vs [X|Vs].
ptmvars (constp _ _) L L.
ptmvars (combp X Y) Vs Ws :- ptmvars X Vs Us, ptmvars Y Us Ws.
ptmvars (typing X T_) Vs Ws :- ptmvars X Vs Ws.
ptmvars (lamp V_ B) Vs Ws :-
  pi x \ (pi L\ ptmvars x L L) => ptmvars (B x) Vs Ws.

%% ----------------------------------------------------------------------------
%% Handy macros for building pretypes and preterms.
%% ----------------------------------------------------------------------------

% Types.
macro @dty :- ptycon "" [].
macro @tybool :- ptycon "bool" [].
macro @tycon A :- ptycon A [].
macro @tyfun A B :- ptycon "fun" [A, B].
macro @tyfun2 A B C :- @tyfun A (@tyfun B C).
macro @aaty :- uty "A".
macro @bbty :- uty "B".

%% ----------------------------------------------------------------------------
%% Turning nominal abstractions into bound HOAS abstractions and recognizes
%% global constants declared in `env`
%% That is (absp _ _) into (lamp _ _)
%%         (varp S _) into (constp S T)
%% ----------------------------------------------------------------------------

pred skeleton i:string, o:pretype. % Generic type of overloaded constants
pred overload i:string, o:string, o:cpretype. % overload S as S1 : T
pred env i:string, o:string, o:cpretype. % resolve S as S : T
pred numeral i:string, o:preterm.

pred ptmbind i:preterm, o:preterm.

ptmbind T1 T2 :-
  (pi S V T B FRESH\
     ptmcopy (absp (varp S _ as V) T) (lamp (varp S FRESH) B) :- !,
        pi v \ (ptmcopy V v :- !) => ptmcopy T (B v))
  =>
  (pi S V T B S VT\
     ptmcopy (absp (typing (varp S _ as V) VT) T) (lamp (varp S VT) B) :- !,
        pi v \ (ptmcopy V v :- !) => ptmcopy T (B v))
  =>
  (pi S TY\
     ptmcopy (varp S TY) (constp S TY) :- (env S _ _; overload S _ _), !)
  =>
  (pi S N\
     ptmcopy (varp S _) N :- numeral S N, !)
  =>
  ptmcopy T1 T2.

%% ----------------------------------------------------------------------------
%% Turning bound HOAS abstractions into nominal abstractions.
%% (That is (absp _ _) into (lamp _ _).
%% ----------------------------------------------------------------------------

pred ptmunbind i:preterm, o:preterm.

ptmunbind T1 T2 :-
  (pi V T X\
     (ptmcopy (lamp V T) (absp V X) :- !, ptmcopy (T V) X))
  => ptmcopy T1 T2.

%% ----------------------------------------------------------------------------
%% Computing the closed preterm (type cpreterm) associated to a preterm.
%% ----------------------------------------------------------------------------

% Closure in a given context.
pred ptmclose i:list preterm, i:preterm, o:cpreterm.

ptmclose [] P (ptmbody Q) :- ptmcopy P Q.
ptmclose [V|Vs] P (ptmfree V B) :-
  pi v \ (ptmcopy V v :- !) => ptmclose Vs P (B v).

% The main predicate: Closure of a pretype.
pred close-term i:preterm, o:cpreterm.

close-term P T :- ptmbind P Q, ptmvars Q [] Vs, ptmclose Vs Q T, !.

%% ----------------------------------------------------------------------------
%% Computing the open preterm associated to a cpreterm.
%% ----------------------------------------------------------------------------

pred open-term i:cpreterm, o:preterm.

open-term (ptmbody X) R :- ptmunbind X R.
open-term (ptmfree V B) X :- open-term (B V) X.

%% ----------------------------------------------------------------------------
%% Free variables.
%%
%% NB: This version of free-vars is for parsed preterms,
%% i.e., for preterms where all variables occurs with a dummy pretype.
%% ----------------------------------------------------------------------------

% Warning: this does not work properly with generalized abstractions.
pred free-vars i:preterm, i:list preterm, o:list preterm.
free-vars (varp S TY) L L1 :-
  overload S S1 _, !,
  (overload _ _ _ :- !, fail) => free-vars (varp S1 TY) L L1.
free-vars (varp S _ as V) L L :- (std.mem! L V ; env S _ _ ; numeral S _), !.
free-vars (varp _ _ as V) L [V|L].
free-vars (typing T _) L L1 :- free-vars T L L1.
free-vars (combp T1 T2) L L2 :-
  free-vars T1 L  L1,
  free-vars T2 L1 L2.
free-vars (absp (varp _ _ as V) T) L L1 :-
  (pi L\ free-vars V L L :- !) =>
  free-vars T L L1.
free-vars (absp (typing (varp _ _ as V) _) T) L L1 :-
  (pi L\ free-vars V L L :- !) =>
  free-vars T L L1.

% Alternative version that works with GABS.
pred freevars i:preterm, o:list string.
freevars (varp S _) [] :- numeral S _N, !.
freevars (varp S _) [] :- hol.interface S [_|_], !.
freevars (varp S _) [] :- env S _ _, !.
freevars (varp S _) [S].
freevars (typing X _) Vs :- freevars X Vs.
freevars (combp X Y) Vs :- union {freevars X} {freevars Y} Vs.
freevars (absp X Y) Vs :-
  freevars X Us,
  (pi S \ freevars (varp S _) [] :- std.mem! Us S, !) => freevars Y Vs.

%% ----------------------------------------------------------------------------
%% Free variables.
%% ----------------------------------------------------------------------------

pred frees i:preterm, o:list preterm.
frees (varp _ _ as V) [V].
frees (constp _ _) [].
frees (combp X Y) Vs :- union {frees X} {frees Y} Vs.
frees (absp X Y) Vs :-
  frees X Us,
  (frees V [] :- std.mem! Us V, !) => frees Y Vs.
frees (typing X _) Vs :- frees X Vs.

pred union i:list A, i:list A, o:list A.
union [] Ys Ys.
union [X|Xs] Ys Zs :- std.mem! Ys X, !, union Xs Ys Zs.
union [X|Xs] Ys [X|Zs] :- union Xs Ys Zs.

pred subtract i:list A, i:list A, o:list A.
subtract [] _ [].
subtract [X|Xs] Ys Zs :- std.mem! Ys X, !, subtract Xs Ys Zs.
subtract [X|Xs] Ys [X|Zs] :- subtract Xs Ys Zs.

pred pmk_forall i:preterm, i:preterm, o:preterm.
pmk_forall (varp _ A as V) X
  (combp (constp "!" (@tyfun (@tyfun A @tybool) @tybool)) (absp V X)).

pred list_pmk_forall i:list preterm, i:preterm, o:preterm.
list_pmk_forall [] X X.
list_pmk_forall [V|Vs] X Y :- list_pmk_forall Vs X Z, pmk_forall V Z Y.

%% ----------------------------------------------------------------------------
%% Basic type-checking algorithm for HOL on preterms.
%% ----------------------------------------------------------------------------

%% NB: the second argument needs the output mode.
pred has_type i:preterm, o:pretype.
has_type (varp _ A) A.
has_type (constp _ A) A.
has_type (combp X Y) B :- has_type X (@tyfun A B), has_type Y A.
has_type (absp (varp _ A) X) (@tyfun A B) :- has_type X B.
has_type (typing X A) A :- has_type X A.

%%% ---------------------------------------------------------------------------
%%% Coercions.
%%% ---------------------------------------------------------------------------

kind coercion type.
type coercion string -> cpretype -> coercion.

pred coercions o:list coercion. % DB

pred trans-coercion o:pretype, o:pretype, o:preterm, o:preterm.
trans-coercion X X1 T T :- X == X1, !.
trans-coercion X X T T.
trans-coercion A B T R1 :-
  coercions Coercions,
  %print "looking for a coercion" A "->" B "for" T,
  std.mem Coercions (coercion S TS),
  %print "attempt" S ":" TS,
  refresh-cpretype TS (ptycon "fun" [A, A1]),
  trans-coercion A1 B (combp (constp S (ptycon "fun" [A, A1])) T) R1.

%%% ---------------------------------------------------------------------------
%%% Tests.
%%% ---------------------------------------------------------------------------

shorten test.{ test, run-tests,
               ok-all, ok-ex, ok, ko, okb, kob, ok-eq, section }.
shorten verbosity.{ quiet, terse, info, verbose, debug, with-verbosity }.

pred pre_hol_tests o:test.
pre_hol_tests T :-
T =
section "pre_hol_tests"
[ section "Pre HOL"
  [ ok-eq [uty "x"] (ptyvars (uty "x") [])
  , ok-eq [sty 1] (ptyvars (sty 1) [])
  , ok-eq [sty 3, uty "x"] (ptyvars (ptycon "y" [uty "x", sty 3]) [])
  , ok-eq (ptyfree (uty "x") A \ (ptybody A))
          (ptyclose [uty "x"] (uty "x"))
  , ok-eq (ptyfree (sty 1) A \ ptybody (uty "x"))
          (ptyclose [sty 1] (uty "x"))
  , ok-eq (ptyfree (sty 1) A \ ptyfree (uty "x") B \
             ptybody (ptycon "fun" [B, A]))
          (close-pretype (ptycon "fun" [uty "x", sty 1]))
  , ok-eq (lamp (varp "x" _) B \ B)
          (ptmbind (absp (varp "x" (uty "t")) (varp "x" (uty "t"))))
  , ( ok-all c \ ok-eq (lamp (varp "x" c) B \ varp "x" (uty "t"))
        (ptmbind (absp (varp "x" c) (varp "x" (uty "t")))) )
  , ( ok-ex A \ ok-eq (lamp (varp "x" A) B \ varp "x" (uty "t"))
        (ptmbind (absp (varp "x" (sty 0)) (varp "x" (uty "t")))) )
  , ok-eq [varp "y" (sty 1), varp "x" (uty "t")]
          (ptmvars (combp (varp "x" (uty "t")) (varp "y" (sty 1))) [])
  , ok-eq (ptmfree (varp "x" (uty "t")) A \ ptmbody A)
          (close-term (varp "x" (uty "t")))
  , ok-eq (ptmfree (varp "x" (uty "s")) A \
             ptmbody (lamp (varp "x" _) B \ combp B A))
          (close-term (absp (varp "x" (uty "t"))
            (combp (varp "x" (uty "t")) (varp "x" (uty "s")))))
  ]
, section "free-vars"
  [ ok-eq [varp "y" (ptycon "" [])]
          (free-vars (absp (varp "x" (ptycon "" []))
                        (varp "y" (ptycon "" []))) [])
  ]
, section "freevars"
  [ ok-eq ["y"]
      (freevars (absp (varp "x" (ptycon "" [])) (varp "y" (ptycon "" []))))
  ]
, section "frees"
  [ ok-eq [varp "x" @aaty, varp "y" @bbty]
      (frees (combp (varp "x" @aaty) (varp "y" @bbty)))
  , ok-eq [varp "x" @aaty, varp "x" @bbty]
      (frees (combp (varp "x" @aaty) (varp "x" @bbty)))
  , ok-eq [varp "x" @aaty]
      (frees (combp (varp "x" @aaty) (varp "x" @aaty)))
  , ok-eq [varp "y" @aaty]
      (frees (absp (varp "x" @aaty) (combp (varp "x" @aaty) (varp "y" @aaty))))
  , ok-eq [varp "y" (uty "A")]
      (frees (absp (varp "x" (uty "A"))
        (combp (varp "x" (uty "A")) (varp "y" (uty "A")))))
  ]
, section "has_type"
  [ ok (has_type (varp "x" (uty "A")) (uty "A"))
  , ok (has_type (constp "y" (uty "U")) (uty "U"))
  , ok (has_type (combp (constp "f" (ptycon "fun" [uty "A", uty "B"]))
                        (varp "x" (uty "A")))
                 (uty "B"))
  ]
, section "pmk_forall"
  [ ok-eq
      (combp
        (constp "!" (@tyfun (@tyfun (uty "A") @tybool) @tybool))
        (absp (varp "x" (uty "A")) (constp "a" @tybool)))
      (pmk_forall (varp "x" (uty "A")) (constp "a" @tybool))
  , ok-eq @tybool
      (has_type
        (combp
          (constp "!" (@tyfun (@tyfun (uty "A") @tybool) @tybool))
          (absp (varp "x" (uty "A")) (constp "a" @tybool))))
  ]
].
