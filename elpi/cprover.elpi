namespace prover {

%%% ---------------------------------------------------------------------------
%%% Simple intuitionistic prover.
%%% ---------------------------------------------------------------------------

pred memb_and_rest o:A, o:list A, o:list A.

memb_and_rest A [A|L] L.
memb_and_rest A [B|L] [B|K] :- memb_and_rest A L K.

%% ----------------------------------------------------------------------------
%% FOL formulas.
%% ----------------------------------------------------------------------------

kind formula type -> type -> type.

type and, or, imp       formula I A -> formula I A -> formula I A.
%type neg               formula I A -> formula I A.
type forall, exists     (I -> formula I A) -> formula I A.
type bottom             formula I A.
type atom               A -> formula I A.

infixl or  4.
infixl and 5.
infixr imp 6.
infix -->   3.

kind  seq   type -> type -> type.
type  -->   list (formula I A) -> list (formula I A) -> seq I A.

kind  proof     type -> type -> type.

type  and_l     proof I A -> proof I A.
type  and_r     proof I A -> proof I A -> proof I A.

type  or_l      formula I A -> formula I A -> proof I A -> proof I A -> proof I A.
type  or1_r     formula I A -> proof I A -> proof I A.
type  or2_r     formula I A -> proof I A -> proof I A.
type  orc_r     proof I A -> proof I A.

type  ex-falso  proof I A.

type  initial   (formula I A) -> proof I A.

type  imp_l     proof I A -> proof I A -> proof I A.
type  imp_r     formula I A -> proof I A -> proof I A.

type  forall_l  proof I A -> proof I A.
type  exists_r  i -> proof I A -> proof I A.

type  forall_r  (i -> formula I A) -> (i -> proof I A) -> proof I A.
type  exists_l  (i -> formula I A) -> (i -> proof I A) -> proof I A.

% TODO: Check this.
pred memb i:formula I A, i:list (formula I A).
memb A L :- std.mem L A.

pred search i:bool, o:proof I A, i:seq I A.

%%% Step 1.

search S (and_l P) (Gamma --> Delta) :-
    memb_and_rest (A and B) Gamma Gamma1,
    search S P ([A,B|Gamma1] --> Delta).

search _S (initial A) (Gamma --> Delta) :-
    memb A Gamma, memb A Delta.

search S (and_r P1 P2) (Gamma --> Delta) :-
    memb_and_rest (A and B) Delta Delta1,
    search S P1 (Gamma --> [A|Delta1]),
    search S P2 (Gamma --> [B|Delta1]).

search S (imp_l P1 P2) (Gamma --> Delta) :-
    memb_and_rest (A imp B) Gamma Gamma1,
    search S P1 (Gamma1 --> [A|Delta]),
    search S P2 ([B|Gamma1] --> Delta).

search S (imp_r A P) (Gamma --> Delta) :-
    memb_and_rest (A imp B) Delta Delta1,
    search S P ([A|Gamma] --> [B|Delta1]).

search S (forall_r A P) (Gamma --> Delta) :-
    memb_and_rest (forall A) Delta Delta1,
    std.spy(pi T\ search S (P T) (Gamma --> [A T|Delta1])).

search S (exists_l A P) (Gamma --> Delta) :-
    memb_and_rest (exists A) Gamma Gamma1,
    pi T\ search S (P T) ([A T|Gamma1] --> Delta).

search _S ex-falso (Gamma --> _Delta) :-
    std.mem! Gamma bottom.

search S (or_l A B P Q) (Gamma --> Delta) :-
    memb_and_rest (A or B) Gamma Gamma1,
    search S P ([A|Gamma1] --> Delta),
    search S Q ([B|Gamma1] --> Delta).

search S (orc_r P) (Gamma --> Delta) :-
    memb_and_rest (A or B) Delta Delta1,
    search S P (Gamma --> [A,B|Delta1]).

search ff P Seq :-
    nsearch 1 P Seq.

%%% Step 2

search tt (forall_l P) (Gamma --> Delta) :-
    memb_and_rest (forall A) Gamma Gamma1,
    search tt P ([A T_|Gamma1] --> Delta).

search tt (exists_r T P) (Gamma --> Delta) :-
    memb_and_rest (exists A) Delta Delta1,
    search tt P (Gamma --> [A T|Delta1]).

%% ----------------------------------------------------------------------------
%% Iterative deepening.
%% ----------------------------------------------------------------------------

pred nsearch i:int, o:proof I A, i:seq I A.
nsearch N P Seq :- N > 5, !, halt "too deep".
nsearch N P Seq :- amplify N Seq ASeq, search tt P ASeq, !.
nsearch N P Seq :- M is N + 1, print "Search at depth " M, nsearch M P Seq.

%% ----------------------------------------------------------------------------
%% Amplify.
%% ----------------------------------------------------------------------------

pred amplify i:int, i:seq I A, o:seq I A.
amplify 1 Seq Seq.
amplify N (Gamma1 --> Delta1) (Gamma2 --> Delta2) :-
    N > 1,
    amplify_forall N Gamma1 Gamma2,
    amplify_exists N Delta1 Delta2.

pred add_copies i:int, i:A, i:list A, o:list A.
add_copies 1 A L [A|L].
add_copies N A L [A|K] :-
    N > 1, M is N - 1,
    add_copies M A L K.

pred amplify_forall i:int, i:list (formula I A), o:list (formula I A).
amplify_forall _N [] [].
amplify_forall N [forall A|Gamma] Gamma2 :-
    amplify_forall N Gamma Gamma1,
    add_copies N (forall A) Gamma1 Gamma2.
amplify_forall N [A|Gamma] [A|Gamma1] :-
    amplify_forall N Gamma Gamma1.

pred amplify_exists i:int, i:list (formula I A), o:list (formula I A).
amplify_exists _N [] [].
amplify_exists N [exists A|Delta] Delta2 :-
    amplify_exists N Delta Delta1,
    add_copies N (exists A) Delta1 Delta2.
amplify_exists N [A|Delta] [A|Delta1] :-
    amplify_exists N Delta Delta1.

pred start o:proof I A, i:seq I A.
start P Seq :- search ff P Seq.
%% ----------------------------------------------------------------------------
%% Nominal variant of forall_r and exists_l proof constructors.
%% ----------------------------------------------------------------------------

type  nforall_r  I -> (formula I A) -> proof I A -> proof I A.
type  nexists_l  I -> (formula I A) -> proof I A -> proof I A.

%% ----------------------------------------------------------------------------
%% Translation to nomial proofs.
%% ----------------------------------------------------------------------------

pred nproof i:proof I A, o:proof I A.

% type  and_l     proof -> proof.
nproof (and_l P) (and_l Q) :-
    nproof P Q.

%type  and_r     proof -> proof -> proof.
nproof (and_r P1 P2) (and_r Q1 Q2) :-
    nproof P1 Q1,
    nproof P2 Q2.

%type  or_l      form -> form -> proof -> proof -> proof.
nproof (or_l A B P1 P2) (or_l A B Q1 Q2) :-
    nproof P1 Q1,
    nproof P2 Q2.

%type  or1_r     form -> proof -> proof.
%type  or2_r     form -> proof -> proof.
%type  orc_r     proof -> proof.

nproof (orc_r P) (orc_r Q) :-
    nproof P Q.

%type  ex-falso  proof.
nproof ex-falso ex-falso.

%type  initial   form -> proof.
nproof (initial A) (initial A).

%type  imp_l     proof -> proof -> proof.
nproof (imp_l P1 P2) (imp_l Q1 Q2) :-
    nproof P1 Q1,
    nproof P2 Q2.

%type  imp_r     form -> proof -> proof.
nproof (imp_r A P) (imp_r A Q) :-
    nproof P Q.

%type  forall_l  proof -> proof.
nproof (forall_l P) (forall_l Q) :-
    nproof P Q.

%type  exists_r  i -> proof -> proof.
nproof (exists_r X P) (exists_r X Q) :-
    nproof P Q.


% type  forall_r  (i -> form) -> (i -> proof) -> proof.

type tvar int -> i.

nproof (forall_r A P) (nforall_r (tvar N) (A X) (P X)) :-
    new_int N, X = tvar N.

%type  exists_l  (i -> form) -> (i -> proof) -> proof.

nproof (exists_l A P) (nexists_l (tvar N) (A X) (P X)) :-
    new_int N, X = tvar N.

%% ----------------------------------------------------------------------------
%% Tests.
%% ----------------------------------------------------------------------------

kind form type.
kind i    type.

type c  i.
type f  i -> i -> i.
type q  form.
type p  i -> form.
type x form.
type d i -> form.

pred test.
test :-
    std.spy(start P ([atom x] --> [atom x])), !,
    std.spy(start P2 ([bottom] --> [bottom])), !,
    std.spy(start P4 ([] --> [(atom x or ((atom x) imp bottom))])), !,
    std.spy(start P3 ([] --> [exists x\ (atom (d x)) imp (forall y\ atom (d y))])),
    std.spy(nproof P3 P3N).

}

% TODO: elpi should "patch" notations inside namespaces automatically
infixl prover.or  4.
infixl prover.and 5.
infixr prover.imp 6.