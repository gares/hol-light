%%% ===========================================================================
%%% Elaborator for type inference and term reconstruction.
%%%
%%% Needs pre_hol.elpi.
%%% ===========================================================================

%% ----------------------------------------------------------------------------
%% Handy macros.
%% ----------------------------------------------------------------------------

macro @dummy :- ptycon "" [].
macro @fun L :- ptycon "fun" L.
macro @con X :- ptycon X [].

macro @bool    :- @con "bool".
macro @num     :- @con "num".
macro @real    :- @con "real".
macro @complex :- @con "complex".

macro @var S :- varp S @dummy.

%% ----------------------------------------------------------------------------
%% entrypoint
%% ----------------------------------------------------------------------------

pred elab i:preterm, o:preterm.

%% ----------------------------------------------------------------------------
%% main
%% ----------------------------------------------------------------------------

shorten verbosity.{ quiet, terse, info, verbose, debug, when-verbosity }.

elab T R :-
  % we assume a SINGLE type for each free variable
  freevars T VS, std.map VS build-clause-fv VST, (VST =>
   (
    % we try with no coercions
    ((coercions [] :- !) => of T TY R)
    %%% TODO: With coercions diverges in some cases.
    %  ;
    % % we try again with coercions
    % (of T TY R)
   )
  ),
  when-verbosity debug (print VS "|-" T "\n-e->\n" R ":" TY).

pred build-clause-fv i:string, o:prop.

build-clause-fv S (of (varp S _) Ty (varp S Ty) :- !).

%% ----------------------------------------------------------------------------
%% typing
%% ----------------------------------------------------------------------------

pred of o:preterm, o:pretype, o:preterm.

:name "of:constant"
of (varp S DTY) TY T :-
  overload S S1 CTY,
  refresh-cpretype CTY TY,
  (overload _ _ _ :- !, fail) => of (varp S1 DTY) TY T.
of (varp S _) (@con "num") N :- numeral S N, !.
of (varp S _) TY (constp S TY) :- env S S CTY, refresh-cpretype CTY TY.

pred is_varp o:string, o:pretype.

:name "of:abstraction"
of (absp X Y) (@fun [A,B]) (absp X1 Y1) :-
  freevars X Us,
  std.map Us build-clause-fv Cs,
  Cs => of X A X1,
  Cs => of Y B Y1.

:name "of:application"
of (combp A B) Tgt (combp A1 B1) :-
  of A (@fun [Src,Tgt]) A1,
  of-coerce B Src B1.
of (typing T TY) TY T1 :-
  of-coerce T TY T1.

%% ----------------------------------------------------------------------------
%% coercing
%% ----------------------------------------------------------------------------

% like of, but can cast the term inserting a coercion
pred of-coerce i:preterm, o:pretype, o:preterm.

of-coerce A T R :-
  /*report-all-failures-if-no-success*/ (
  of A T1 R1,
  (
    (trans-coercion T1 T R1 R)
  /*
    ( Msg is "error"/*"The term\n\t" ^ {hol.term->string R1} ^
             "\nhas type\n\t" ^ {hol.ty->string T1} ^
             "\nthat is not\n\t" ^ {hol.ty->string T}*/,
       error [ Msg ]
    )*/
  )
  ).
/*
stash-new E S :- open_safe E L, ( std.mem L S ; stash_in_safe E S ), !.

report-all-failures-if-no-success P :-
  new_safe E,
  (((pi ML\ error ML :- !, std.forall ML (stash-new E), fail) => P)
   ;
   (error {open_safe E})).

error L :- std.forall L (x\ print "Error:" x), fail.
*/

%% ----------------------------------------------------------------------------
%% Tests.
%% ----------------------------------------------------------------------------

pred tiny_env o:list prop.
tiny_env
  [ env "0" "0" (ptybody @num)
  , env "real_of_num" "real_of_num" (ptybody (@fun [@num, @real]))
  , env "complex_of_real" "complex_of_real" (ptybody (@fun [@real, @complex]))
  , coercions [coercion "real_of_num" (ptybody (@fun [@num, @real]))]
  ].

pred small_env o:list prop.
small_env
  [ env "0" "0" (ptybody @num)
  , env "real_of_num" "real_of_num" (ptybody (@fun [@num, @real]))
  , env "complex_of_real" "complex_of_real" (ptybody (@fun [@real, @complex]))
  , coercions
    [ coercion "real_of_num"     (ptybody (@fun [@num,  @real]))
    , coercion "complex_of_real" (ptybody (@fun [@real, @complex]))
    ]
  ].

shorten test.{ test, run-tests, ok, ko, okb, kob, ok-eq, assert, section }.

macro @tm0 :-
  (combp (constp "NUMERAL" (ptycon "fun" [ptycon "num" [], ptycon "num" []]))
    (constp "_0" (ptycon "num" []))).

pred elab_tests o:test.
elab_tests T :-
  tiny_env TinyEnv,
  small_env SmallEnv,
  T =
  section "elab_tests"
  [ assert TinyEnv
    ( section "TinyEnv"
      [ section "close-term"
        [ ok-eq
            (ptmfree (varp "y" (uty "t")) Y \
              ptmbody (lamp (varp "x" (@con "1")) X \
                combp Y (combp X @tm0)))
            (close-term
              (absp (varp "x" (uty "t"))
                (combp (varp "y" (uty "t"))
                  (combp (varp "x" (uty "t")) (@var "0")))))
        , ok-eq
            (ptmfree (varp "y" (uty "t")) Y \
              ptmbody (lamp (varp "x" (uty "t")) X \
                combp Y (combp X @tm0)))
            (close-term
              (absp (varp "x" (uty "t"))
                (combp (varp "y" (uty "t"))
                  (combp (varp "x" (uty "t")) (@var "0")))))
        ]
      , section "elab"
        [ ok-eq
            (absp (varp "x" (@fun [@num, @con "1"]))
              (combp (varp "y" (@fun [@con "1", @con "2"]))
                (combp (varp "x" (@fun [@num, @con "1"]))
                  @tm0)))
            (elab (absp (varp "x" (uty "t"))
              (combp (varp "y" (uty "t"))
                (combp (varp "x" (uty "t")) (@var "0")))))
        , section "elab w/ coercions"
          [ ok-eq
              (absp (varp "x" (@fun [@real, @bool]))
                (combp (varp "y" (@fun [@bool, @con "1"]))
                  (combp (varp "x" (@fun [@real, @bool]))
                    (combp
                      (constp "real_of_num" (@fun [@num, @real]))
                      @tm0))))
              (elab
                (absp (typing (varp "x" (uty "t")) (@fun [@real, @bool]))
                  (combp (varp "y" (uty "t"))
                    (combp (varp "x" (uty "t")) (@var "0")))))
          ]
        ]
      ]
    )
  , assert SmallEnv
    ( section "SmallEnv"
      [ ok-eq
          (absp (varp "x" (@fun [ptycon "complex" [], @bool]))
            (combp (varp "x" (@fun [ptycon "complex" [], @bool]))
              (combp
                (constp "complex_of_real" (@fun [@real, ptycon "complex" []]))
                (combp
                  (constp "real_of_num" (@fun [@num, @real]))
                  @tm0))))
          (elab
            (absp (typing (varp "x" (uty "t")) (@fun [@con "complex", @bool]))
              (combp (varp "x" (uty "t")) (@var "0"))))
      ]
    )
  ].
