1. Benchmarks:
  - hack `prove` to call Hol_elpi.elaborate on the preterm
    and see
    - does it work
    - how fast
  - repeat removing from the preterm all the constants in !the_coercions
    `&1` -> `1` (see also #3)

2. cprover sui pretermini direttamente
   - oppure pigliare da handbook AR prover intuizionista

3. Round trip printing -> elaboration (necessita #2)

    elab normale:

       (x:real) + y
       (x_real) (+_R->R->R) (y_real)

    elab dove overload diventa skeleton
 
       x + y
       (x_A) (+_A->A->A) (y_A)

   passo min-fill

       (annot x_real) (+_R->R->R) (y_real)
       (annot x_real) (real_add_R->R->R) (y_real)

     min-fill i:preterm, i:preterm, o:preterm.
     min-fill FullElab SkelElab MinElab.

     min-fill (varb S T) (varb S V) 
                (combp (const "annot" {{ ^T -> ^T }}) (varb S T)) :- var V, V = T. 
     min-fill (combp A B) (combp A1 B1) (combp A2 B2) :- ...

   stampa dove "annot (x_T)" diventa "x : T"

   Per le coercion, l'inserimento dovrebbe diventare deterministico
   se il tipo del "castato" e del contesto sono ground. Problema tipico
   nei lemmi di morfismo a proposito delle coercions.
     &x + &x = &(x + x)

4. soft dependent types
                                          subject, pred, proof
     `!`   CONS x NIL :: vect 1 (A) `!` = term * term * thm
     ```   CONS x NIL :: vect 1 (A) ``` = term * term

   use a TT like language in elpi, then convert back to HOL

----------------------------------------------------
To Do list

- Typechecker (informative type errors?)
- Classes (see what they do in Isabelle)
- Tactic language + new ITAUT
- Isar?
- Proof outlines (Roberto Blanco)
- HO unification
- immersione MLTT (basata sui PER) e usare il type checker
  come un dimostratore degli invarianti esprimibili in TT
    ``` m1 * m2 = m3 :: Prop ==> ``` con ```m1 : 'M(n,m) ``` 

   `m1 * m2 = m3 /\ rows m1 = cols m2 /\ .... ==> `

   `!m. is_matrix m m /\ cols m = rows m   => m * m = m`

   


======================================

Discussione sulle classi:

1) risultato dell'inferenza di tipo, dove ?? Ã¨ un esiste speciale che
   risolviamo con elpi (subito dopo l'elaborazione che facciamo ora, ma
   avendo accesso al contesto di prova).

 t : type
 r : (t)ring
 Hr : is_ring r
------------------------
 ??m : (t)monoid. is_monoid m /\
 ??g : (t)group. is_group g /\
   !x y : t.(op : (A)monoid -> A -> A) m (x : t) y = (ginv : (A)group -> A -> A) g x`;;

2) le istanze trovate sono una sorta di reificazione della prova a partire dal contesto,
   la ricerca va fatta in modo non solo backward, ma usando il contesto e il goal allo stesso tempo, altrimenti
   cadiamo nel problema di efficenza delle classi di tipo in Coq (che invece le strutture canoniche non hanno)

 t : type
 r : (t)ring
 Hr : is_ring r
------------------------
   !x y : t.(op : (A)monoid -> A -> A) (r2m r) (x : t) y = (ginv : (A)group -> A -> A) (r2g r) x`

altro esempio

   !x : t. ginv (r2g r) (ginv (r2g r) x) = x.

3) l'applicazione di un teorema ha ipotesi che uno deve soddisfare usando la
   base di conoscenza algebrica, se non ci riesec allora non si applica proprio?


   !x : s. !g : (s)group. is_group g ==> x IN g ==> ginv g (ginv g x) = x.

                          ^^^^hyp^^^

Esempio classico in math-comp:


 is_group H
--------------
  one ?g IN (H & f @ G)                     forall t, is_group t -> 1 IN t
                                                   r, is_ring r -> is_group (r2g r) -> 1 IN (r2g r)


is_group (A & B) J :-  is_group A J1 , is_group_B J2, J = mmm.


 
  

