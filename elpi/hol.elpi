

overload S S1 CT :-
  hol.interface S L,
  resolve-overload L S1 CT,
  print "overloading" S "->" S1.

env S S CT :-
  hol.env S T, close-pretype T CT.

pred resolve-overload i:(list (pair string pretype)), o:string, o:cpretype.

resolve-overload [pr S T|_] S CT :-
  close-pretype T CT.

resolve-overload [_|REST] S CT :- resolve-overload REST S CT.

numeral S N :-
  hol.pmk_numeral S N.

coercions L :-
  hol.coercions C,
  std.map C close-coercion L.

pred close-coercion i:(pair string pretype), o:coercion.
close-coercion (pr S T) (coercion S CT) :-
  close-pretype T CT.

prove (combp (combp (constp "=" _) X) X) Thm :-
  hol.rule.refl X Thm.

pred hol2prover i:preterm, o:prover.formula preterm preterm.

hol2prover {{ ^A /\ ^B }} (A1 prover.and B1) :-
  hol2prover A A1,
  hol2prover B B1.

hol2prover {{ ^A \/ ^B }} (A1 prover.or B1) :-
  hol2prover A A1,
  hol2prover B B1.

hol2prover {{ ^A ==> ^B }} (A1 prover.imp B1) :-
  hol2prover A A1,
  hol2prover B B1.

hol2prover {{ F }} prover.bottom.

hol2prover {{ ! ^V . ^B }} (prover.forall V F1) :-
  pi x\ ptmcopy V x => ptmcopy B (F x), 
        ptmcopy x x => hol2prover (F x) (F1 x).

hol2prover {{ ? ^V . ^B }} (prover.exists V F1) :-
  pi x\ ptmcopy V x => ptmcopy B (F x),
        ptmcopy x x => hol2prover (F x) (F1 x).

hol2prover X (prover.atom X).

pred prover2hol i:prover.formula preterm preterm, o:preterm.

prover2hol (A1 prover.and B1) {{ ^A /\ ^B }}  :-
  prover2hol A1 A,
  prover2hol B1 B.

prover2hol (A1 prover.or B1) {{ ^A \/ ^B }}  :-
  prover2hol A1 A,
  prover2hol B1 B.

prover2hol (A1 prover.imp B1) {{ ^A ==> ^B }}  :-
  prover2hol A1 A,
  prover2hol B1 B.

prover2hol prover.bottom {{ F }} .

prover2hol (prover.forall V F1) {{ ! ^V . ^B }} :-
  prover2hol (F1 V) B.

prover2hol (prover.exists V F1) {{ ? ^V . ^B }} :-
  prover2hol (F1 V) B.

prover2hol (prover.atom X) X.

%% ----------------------------------------------------------------------------
%% Nominal variant of forall_r and exists_l proof constructors.
%% ----------------------------------------------------------------------------

type  prover.nforall_r  I -> A -> prover.proof I A -> prover.proof I A.
type  prover.nexists_l  I -> A -> prover.proof I A -> prover.proof I A.

pred nproof i:prover.proof preterm (prover.formula preterm preterm),
            o:prover.proof preterm preterm.

nproof (prover.and_l A B P) (prover.and_l A1 B1 Q) :- 
    prover2hol A A1,
    prover2hol B B1,
    nproof P Q.

nproof (prover.and_r P1 P2) (prover.and_r Q1 Q2) :-
    nproof P1 Q1,
    nproof P2 Q2.

nproof (prover.or_l A B P1 P2) (prover.or_l A1 B1 Q1 Q2) :-
    prover2hol A A1,
    prover2hol B B1,
    nproof P1 Q1,
    nproof P2 Q2.

nproof (prover.or1_r P) (prover.or1_r Q) :-
    nproof P Q.

nproof (prover.or2_r P) (prover.or2_r Q) :-
    nproof P Q.

nproof (prover.orc_r P) (prover.orc_r Q) :-
    nproof P Q.

nproof prover.ex-falso prover.ex-falso.

nproof (prover.initial A) (prover.initial A1) :-
    prover2hol A A1.

nproof (prover.imp_l A B P1 P2) (prover.imp_l A1 B1 Q1 Q2) :-
    prover2hol A A1,
    prover2hol B B1,
    nproof P1 Q1,
    nproof P2 Q2.

nproof (prover.imp_r P) (prover.imp_r Q) :-
    nproof P Q.

nproof (prover.forall_l I F P) (prover.forall_l I F1 Q) :-
    prover2hol F F1,
    nproof P Q.

nproof (prover.exists_r X P) (prover.exists_r X Q) :-
    nproof P Q.

pred fresh_varb o:preterm.
fresh_varb (varp S (@con "")) :-
  new_int N,
  S is "var" ^ {term_to_string N}.

nproof (prover.forall_r A P) (prover.nforall_r X A1 P1) :-
   fresh_varb X,
   prover2hol (A X) A1,
   nproof (P X) P1.

nproof (prover.exists_l A P) (prover.nexists_l X A1 P1) :-
   fresh_varb X,
   prover2hol (A X) A1,
   nproof (P X) P1.

pred search i:list preterm, i:preterm, o:prover.proof preterm preterm.
search H C NP :- std.spy-do! [
  hol2prover C C1,
  std.map H hol2prover H1,
  prover.start P H1 [C1],
  nproof P NP
].

/*
% terms %%%%%%%%%%%%%%%%

kind term type. % a preterm actually

type app     term -> term -> term.
type varb    string -> ty -> term.
type lam     term -> term -> term.
type typing  term -> ty -> term.
type const   string -> ty -> term.

kind ty type. % a pretype actually

type tyvar   string -> ty.
type tyapp   string -> list ty -> ty.

kind tys type.

type mono ty -> tys.
type all  (ty -> tys) -> tys.

pred refresh-tys i:tys, o:ty.

refresh-tys (mono T) T.
refresh-tys (all F) T :- refresh-tys (F FRESH_) T.

pred of i:term, o:ty, o:term.

macro @dummy :- tyapp "" [].

% variable dispatching

of (varb V _) T  R :- hol.pmk_numeral V N, !,
  of N T R.

of (varb V _) T R :- (hol.interface V [_|_] ; hol.env V _), !,
  of (const V @dummy) T R.
  
of (varb S @dummy) Ty (varb S Ty) :- free? S (varb _ Ty).

% constants: 
of (const S _) T (const S T) :- hol.interface S [],
  hol.env S T1, refresh-tys T1 T.

of (const S _) T (const S1 T) :-
  hol.interface S L,
  mem L (pr S1 T).

of (lam V B) (tyapp "fun" [Src,Tgt]) (lam (varb S Src) B1) :-
  of V Src (varb S Src),
  (pi U Src1 \ of (varb S _) Src1 U :- !, U = varb S Src, Src = Src1) =>
    of B Tgt B1.

of (typing T TY) TY T1 :- !, of T TY T1.

of (app H A) Tgt (app H1 A1) :-
  of H (tyapp "fun" [Src,Tgt1]) H1,
  of A Src A1,
  Tgt = Tgt1.

pred of-loop. 

of PTM TY TM :- not (var TY), not of-loop,
  hol.coercions Coercions,
  of-loop => of PTM TY1 TM1,
  mem Coercions (coercion _ TS CTM),
  refresh-tys TS (tyapp "fun" [TY1, TY]),
  TM = app CTM TM1.
	
pred mem i:list A, o:A.
mem [X|_] X.
mem [_|Xs] X :- mem Xs X.

/*
of T (tyapp "fun" [Src, tyapp "real" []]) T3 :-
  of T (tyapp "fun" [Src, tyapp "num" []]) T1,
  T2 = app (app (varb "o" @dummy) (varb "real_of_num" @dummy)) T1,
  of T2 (tyapp "fun" [Src, tyapp "real" []]) T3.

of T ETY R :- not (err),
  ((err => of T TY T1) ; TY = tyapp "no_type" []),
  R = app (const "type_error" (tyapp "fun" [TY,ETY])) T1.
*/      
pred refresh i:ty, o:ty.
refresh TY TY1 :- std.spy(variables TY [] V), std.spy(mk-subst-ty V S), S => copy-ty TY TY1.

pred variables i:ty, i:list ty, o:list ty.
variables (tyvar _ as X) L L :- std.mem L X, !.
variables (tyvar _ as X) L [X|L].
variables (tyapp _ []) L L. 
variables (tyapp S [A|AS]) L L2 :-
  variables A L L1, variables (tyapp S AS) L1 L2. 

pred mk-subst-ty i:list ty, o:list prop.

mk-subst-ty [] [].
mk-subst-ty [X|XS] [copy-ty X FRESH_ | YS] :- mk-subst-ty XS YS.

% "pretty" printer %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
pred pp i:term, o:string.

pp (app A B) S :- pp-app (app A B) [] S.
pp (varb S _) S.
pp (typing T TY) S :- S is "(" ^ {pp T} ^ " : " ^ {ppt TY} ^ ")".
pp (lam T B) S :- S is "Î»" ^ {pp T} ^ ". " ^ {pp B}.

pred pp-app i:term, o:list term, o:string.

pp-app (app A B) L S :- !, pp-app A [B|L] S.
pp-app T L S :- S is "(" ^ {pp T} ^ {pp-list {std.rev L}} ^ ")".

pred pp-list i:list term, o:string.

pp-list [] "".
pp-list [X|XS] S :- S is " " ^ {pp X} ^ {pp-list XS}. 

pred ppt i:ty, o:string.

ppt (tyapp S []) S.
ppt (tyapp "fun" [A,B]) S :- S is {ppt A} ^ " -> " ^ {ppt B}.
ppt (tyapp HD ARGS) S :- S is HD ^ {ppt-list ARGS}.

pred ppt-list i:list ty, o:string.

ppt-list [] "".
ppt-list [X|XS] S :- S is " " ^ {ppt X} ^ {ppt-list XS}.

% main %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred elab i:term, o:term.

pred free-vars o:list term.

pred free? i:string, o:term.

free? S T :-
  free-vars L,
  (of-loop, C = "coercing" ; C = "normal elaboration"),
  print "looking for" S "as a free variable in" L " while" C,
  find-or-add L S T,
  print "resulting env is" L
  .

pred find-or-add i:list term, i:string, o:term.

find-or-add [varb S T|_] S R :- !, R = (varb S T).
find-or-add [_|L] S R :- find-or-add L S R.
find-or-add (uvar as L) S (varb S T) :- L = [(varb S T)|FRESH_].

elab X Y :-
  free-vars L => of X T Y,
  print "elab" X "->" L "|-" Y ":" T.

pred self-test.

self-test :-
  print "test1",
  print {hol.term->string (lam (varb "x" _) (varb "x" _))},

  print "test2",
  print {hol.ty->string (ptycon "num" [])},
  
  print "test3",
  hol.interface "+" L,
  std.map L (map-pr (=) hol.ty->string) L1,
  print "interface + = " L1,
  hol.interface "whatever" [],
  
  print "test4",
  print "int_min : " {hol.ty->string {hol.env "int_min"}},
  not (hol.env "whatever" _),

  print "test5",!,
  print "raw numeral 2 =" {hol.pmk_numeral "2"},
  print "42 =" {hol.term->string {hol.pmk_numeral "42"}},
  not(hol.pmk_numeral "x" _),
  
  print "test6",!,
  print {{\x : num. x}} ":" {{: num -> num}},
  
  %print "test7",
  %of {{ 0 : real }} _ R, print {hol.term->string R},
  
  %print "test8",!,
  %of {{ [] : real}} _ F, print {hol.term->string F},
  
  %print "test9",!,
  %hol.rule.refl {of {{0}} _} Thm, print Thm,

  print "test10",!,
  hol.coercions Cs, print Cs.

% library %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


pred map-pr i:(A -> B -> prop), i:(C -> D -> prop), i:pair A C, o:pair B D.

map-pr F G (pr A B) (pr A1 B1) :- F A A1, G B B1.

pred copy i:term, o:term.

copy (app A B) (app A1 B1) :- copy A A1, copy B B1.
copy (varb S TY) (varb S TY1) :- copy-ty TY TY1.
copy (lam V T) (lam V1 T1) :- copy V V1, copy T T1.
copy (typing T TY) (typing T1 TY1) :- copy T T1, copy-ty TY TY1.
copy (const S TY) (const S TY1) :- copy-ty TY TY1.

pred copy-ty i:ty, o:ty.

copy-ty (tyvar S) (tyvar S).
copy-ty (tyapp S L) (tyapp S L1) :- copy-ty-list L L1.

pred copy-ty-list i:list ty, o:list ty.

copy-ty-list [] [].
copy-ty-list [T|TS] [T1|TS1] :- copy-ty T T1, copy-ty-list TS TS1.

pred prove i:term, o:@thm.

prove (app _ X) Thm :- hol.rule.refl X Thm.

pred step i:goal, o:list goal, o:justification.

step G GL J :-
  hol.tac.ap_term_tac G [SG] J1,
  hol.tac.ap_term_tac SG GL J2,
  J = japp J1 J2.
*/

/*
prove [p X (d X) |..] [not(p X) (d Y)|..] (r X=Y) :-...

eval (app H A) X (l J1 J2) :-
  eval H (lam B) J1, eval A V J2, X = list B V.


kind thm type.

type  refl    term -> thm.
type  assume  term -> thm.
type  conj    thm -> thm -> thm.
type  arith   term -> thm.

pred p . . . 

prove (sequent _ {{ lp:X = lp:X }} (refl X)).
prove (sequent [ P | G] P (weak G (assume P)). 

prove (sequent G {{ lp:P => lp:R }} (... J ..) :-
  prove (sequent [P|G] R J).

prove (sequent [ {{ lp:P /\ lp:Q }} | G ] R (conj_l J) :-
  prove (sequent [P,Q|G] R J).
    
prove (sequent G P J) :- subset (symbols G P) ["+" 

prove (refl X) {{ lp:X = lp:X }}.

prove P {{ 0 = 0 }}.


? prove (sequent `X = 4`)  

?x. x = 4  

             4 = 4
(ex_intro 4  refl      )   (refl 4)).    


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


test :-
  hol.thm "ADD_0" S, print S,
  print {{ \x. x + 1 }},

  print {{: bool^(2) }},
  print {{:pre \x. x + 1}},
  hol.env "+" T, print T,
  print {{: a^(3) }}.
*/

